[
  {
    "id": "00_Simple_MIDI",
    "number": "00",
    "title": "Simple Midi",
    "description": "Takes USB midi, sends it to pulse and CV outputs, also sends knob positions and CV inputs back to the computer as CC values.",
    "language": "Arduino-Pico",
    "creator": "Tom Whitwell",
    "version": "0.5",
    "status": "Working but simple",
    "pdf_files": [
      "releases/00_Simple_MIDI/Documentation/Simple_MIDI_0-1.pdf"
    ],
    "uf2_files": [
      "releases/00_Simple_MIDI/uf2 Installer/Simple_Midi_0_5_0.ino.uf2"
    ],
    "readme": "## Music Thing Modular \n## Workshop System \n\n## Simple Midi Card with Calibration v0.5 \n\nWritten by Tom Whitwell\nIn Herne Hill, London, October 2024 \n\n### How to Calibrate \n- Hold down the momentary toggle switch on startup \n- Release the switch 5 seconds after startup \n- The centre left LED will start to flash\n- Patch the top oscillator in the Workshop System to an output so you can hear it \n- Make sure FM is fully off  \n- Use a tuner to the oscillator to C3\n- Patch the left CV output to the top oscillator 'Pitch' input \n- If the oscillator changes tune (it probably will, a little bit) you need to calibrate 0V\n- Flip the toggle switch up\n- The led will start to flash more slowly \n- Now you can use the big knob and the X knob as coarse/fine controls to set the position of 0v. Fiddle around until C3 is back in tune\n- When you're ready, flip the toggle switch down. \n- Now tap the toggle switch, and the LED will move to the top left LED \n- This indicates it is sending +2V from the left hand output \n- Flip the switch up, and tweak the knobs until the oscillator gives a C5 in tune. \n- Push the switch back to the middle to save that setting, then tap down again to set -2V to C1\n- Tap the switch again, and the LED will move to the right column, in the middle. \n- This represents the 0V output for the right hand CV output. \n- IMPORTANT: Repatch at this point, so the right CV output controls the Bottom oscillator. \n- (The oscillators aren't calibrated, so each output will be calibrated to a specific oscillator's quirks!) \n- You can tap through the voltages to check everything is working as it should, flipping up to change any voltages you're not happy with. \n- Once you're finished, press reset to return to normal MIDI mode. \n\n### Using the Eeprom calibration data in other cards \n- This card includes several useful classes \n- However, I (Tom) wrote it, so it's not very well organised, and can certainly be improved. \n- CV.h is Chris Johnson's delta/sigma code, which pushes 19bit precision from 11 bit PWM \n- DACChannel.h uses the calibration data to create  calibration constants. ChatGPT wrote most of this, so I don't really understand it, but it seems to work. \n- calibration.h organises the reading and writing of data to the Eeprom, with error checking. This was a Tom + ChatGPT collaboration, hopefully a good basis for incorporating the calibration code in other cards. \n    - The memory map for calibration makes space for 10x calibration points for both channels, but this only uses 3. \n    - There are certainly ways to automate the calibration process to make it more precise and easier to use. \n- Click.h is a little short tap/long tap library I wrote for Startup \n\n### PAGE 0 0x50 Memory Map for 2 x Precision PWM Voltage Outputs (Channels 0 and 1)\n\n| Offset | Bytes | Contents                                                                                     |\n|--------|-------|----------------------------------------------------------------------------------------------|\n| 0      | 2     | Magic number = 2001 - if number is present, EEPROM has been initialized                      |\n| 2      | 1     | Version number 0-255                                                                         |\n| 3      | 1     | Padding                                                                                      |\n| 4      | 1     | Channel 0 - Number of entries 0-9                                                            |\n| 5      | 40    | 10 x 4 byte blocks: 1 x 4 bit voltage + 4 bits space \\| 1 x 24 bit setting = 32 bits = 4 bytes |\n| 45     | 1     | Channel 1 - Number of entries 0-9                                                            |\n| 46     | 40    | 10 x 4 byte blocks: 1 x 4 bit voltage + 4 bits space \\| 1 x 24 bit setting = 32 bits = 4 bytes |\n| 86     | 2     | CRC Check over previous data                                                                 |\n| 88     |       | END                                                                                          |\n\n\n\n### Includes \nResponsive Analog Read by Damien Clarke\nhttps://github.com/dxinteractive/ResponsiveAnalogRead\nAdafruit Tiny USB Library \nhttps://github.com/adafruit/Adafruit_TinyUSB_Arduino \nEarle Pilhower's arduino-pico \nhttps://github.com/earlephilhower/arduino-pico  \n\n### Compilation options: \nBoard: Generic RP2040 \nFlash Size: 16MB (No FS) \nCPU Speed: 133MHz \nBoot Stage 2: W25Q16JV QSPI/4 (for the newer 2mb cards) \nUSB Stack: Adafruit TinyUSB \n\n### Installation \n\n- To install the UF2: Push the boot select button (remove the main knob on Computer), it's on the right \n- Connect the front USB to the computer \n- Hold down boot and tap reset (the button at the bottom by the card slot \n- A folder should appear on your desktop called RPI RP2 \n- Drag simplemidi.uf2 into that folder \n- The system should reboot and the folder disappear \n- Now check your DAW for midi interfaces - you should find one called Music Thing Workshop System MIDI or something similar to that ",
    "readme_html": "<h2 id=\"music-thing-modular\">Music Thing Modular</h2>\n<h2 id=\"workshop-system\">Workshop System</h2>\n<h2 id=\"simple-midi-card-with-calibration-v05\">Simple Midi Card with Calibration v0.5</h2>\n<p>Written by Tom Whitwell\nIn Herne Hill, London, October 2024 </p>\n<h3 id=\"how-to-calibrate\">How to Calibrate</h3>\n<ul>\n<li>Hold down the momentary toggle switch on startup </li>\n<li>Release the switch 5 seconds after startup </li>\n<li>The centre left LED will start to flash</li>\n<li>Patch the top oscillator in the Workshop System to an output so you can hear it </li>\n<li>Make sure FM is fully off  </li>\n<li>Use a tuner to the oscillator to C3</li>\n<li>Patch the left CV output to the top oscillator &lsquo;Pitch&rsquo; input </li>\n<li>If the oscillator changes tune (it probably will, a little bit) you need to calibrate 0V</li>\n<li>Flip the toggle switch up</li>\n<li>The led will start to flash more slowly </li>\n<li>Now you can use the big knob and the X knob as coarse/fine controls to set the position of 0v. Fiddle around until C3 is back in tune</li>\n<li>When you&rsquo;re ready, flip the toggle switch down. </li>\n<li>Now tap the toggle switch, and the LED will move to the top left LED </li>\n<li>This indicates it is sending +2V from the left hand output </li>\n<li>Flip the switch up, and tweak the knobs until the oscillator gives a C5 in tune. </li>\n<li>Push the switch back to the middle to save that setting, then tap down again to set -2V to C1</li>\n<li>Tap the switch again, and the LED will move to the right column, in the middle. </li>\n<li>This represents the 0V output for the right hand CV output. </li>\n<li>IMPORTANT: Repatch at this point, so the right CV output controls the Bottom oscillator. </li>\n<li>(The oscillators aren&rsquo;t calibrated, so each output will be calibrated to a specific oscillator&rsquo;s quirks!) </li>\n<li>You can tap through the voltages to check everything is working as it should, flipping up to change any voltages you&rsquo;re not happy with. </li>\n<li>Once you&rsquo;re finished, press reset to return to normal MIDI mode. </li>\n</ul>\n<h3 id=\"using-the-eeprom-calibration-data-in-other-cards\">Using the Eeprom calibration data in other cards</h3>\n<ul>\n<li>This card includes several useful classes </li>\n<li>However, I (Tom) wrote it, so it&rsquo;s not very well organised, and can certainly be improved. </li>\n<li>CV.h is Chris Johnson&rsquo;s delta/sigma code, which pushes 19bit precision from 11 bit PWM </li>\n<li>DACChannel.h uses the calibration data to create  calibration constants. ChatGPT wrote most of this, so I don&rsquo;t really understand it, but it seems to work. </li>\n<li>calibration.h organises the reading and writing of data to the Eeprom, with error checking. This was a Tom + ChatGPT collaboration, hopefully a good basis for incorporating the calibration code in other cards. <ul>\n<li>The memory map for calibration makes space for 10x calibration points for both channels, but this only uses 3. </li>\n<li>There are certainly ways to automate the calibration process to make it more precise and easier to use. </li>\n</ul>\n</li>\n<li>Click.h is a little short tap/long tap library I wrote for Startup </li>\n</ul>\n<h3 id=\"page-0-0x50-memory-map-for-2-x-precision-pwm-voltage-outputs-channels-0-and-1\">PAGE 0 0x50 Memory Map for 2 x Precision PWM Voltage Outputs (Channels 0 and 1)</h3>\n<table>\n<thead>\n<tr>\n<th>Offset</th>\n<th>Bytes</th>\n<th>Contents</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>0</td>\n<td>2</td>\n<td>Magic number = 2001 - if number is present, EEPROM has been initialized</td>\n</tr>\n<tr>\n<td>2</td>\n<td>1</td>\n<td>Version number 0-255</td>\n</tr>\n<tr>\n<td>3</td>\n<td>1</td>\n<td>Padding</td>\n</tr>\n<tr>\n<td>4</td>\n<td>1</td>\n<td>Channel 0 - Number of entries 0-9</td>\n</tr>\n<tr>\n<td>5</td>\n<td>40</td>\n<td>10 x 4 byte blocks: 1 x 4 bit voltage + 4 bits space | 1 x 24 bit setting = 32 bits = 4 bytes</td>\n</tr>\n<tr>\n<td>45</td>\n<td>1</td>\n<td>Channel 1 - Number of entries 0-9</td>\n</tr>\n<tr>\n<td>46</td>\n<td>40</td>\n<td>10 x 4 byte blocks: 1 x 4 bit voltage + 4 bits space | 1 x 24 bit setting = 32 bits = 4 bytes</td>\n</tr>\n<tr>\n<td>86</td>\n<td>2</td>\n<td>CRC Check over previous data</td>\n</tr>\n<tr>\n<td>88</td>\n<td></td>\n<td>END</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"includes\">Includes</h3>\n<p>Responsive Analog Read by Damien Clarke\nhttps://github.com/dxinteractive/ResponsiveAnalogRead\nAdafruit Tiny USB Library \nhttps://github.com/adafruit/Adafruit_TinyUSB_Arduino \nEarle Pilhower&rsquo;s arduino-pico \nhttps://github.com/earlephilhower/arduino-pico  </p>\n<h3 id=\"compilation-options\">Compilation options:</h3>\n<p>Board: Generic RP2040 \nFlash Size: 16MB (No FS) \nCPU Speed: 133MHz \nBoot Stage 2: W25Q16JV QSPI/4 (for the newer 2mb cards) \nUSB Stack: Adafruit TinyUSB </p>\n<h3 id=\"installation\">Installation</h3>\n<ul>\n<li>To install the UF2: Push the boot select button (remove the main knob on Computer), it&rsquo;s on the right </li>\n<li>Connect the front USB to the computer </li>\n<li>Hold down boot and tap reset (the button at the bottom by the card slot </li>\n<li>A folder should appear on your desktop called RPI RP2 </li>\n<li>Drag simplemidi.uf2 into that folder </li>\n<li>The system should reboot and the folder disappear </li>\n<li>Now check your DAW for midi interfaces - you should find one called Music Thing Workshop System MIDI or something similar to that </li>\n</ul>",
    "has_documentation": true,
    "has_firmware": true
  },
  {
    "id": "03_Turing_Machine",
    "number": "03",
    "title": "Turing Machine",
    "description": "Turing Machine with tap tempo clock, 2 x pulse outputs, 4 x CV outputs",
    "language": "Arduino-Pico",
    "creator": "Tom Whitwell",
    "version": "0.1",
    "status": "Working but Simple",
    "pdf_files": [],
    "uf2_files": [
      "releases/03_Turing_Machine/Rev_1_5_UF2/TuringForWorkshop.uf2",
      "releases/03_Turing_Machine/uf2 Installer/03_TuringMachine_0_1_0.uf2"
    ],
    "readme": "# Turing Machine Program Card V1.5  \n\nRead these notes alongside the [previous version instructions](https://www.musicthing.co.uk/Computer_Program_Cards/#03-turing-machine)\n\n## What's new\n- **Clock In**: \n  - Send a clock to Pulse 1 and the tap tempo is replaced with the clock in. \n  - The clock _Diviply_ function that drives Channel 2 will be driven by the external input clock, so can be used as a standalone clock divide/multiply. It's fairly simple - if the external clock changes speed, the diviply clock waits for a second pulse before changing speed itself. I found this more musical/pleasingly weird than attempting to average clock speed changes. \n  - This clock input works into high audio rate, turning the Turing Machine into a random wavetable oscillator. \n  - A clock into Pulse 2 overwrites the diviply clock, so you have two independently clocked Turing Machines. In this case Pulse Out 2 simply mirrors Pulse In 2. \n- **New Editor**: \n  - The web editor has been redesigned to emphasise the two presets accessed with the toggle switch. It now connects to the Workshop Computer using MIDI sysex, which seems more reliable and easier, once MIDI communication has been permitted. Once again, Chrome is the only browser that has been tested, although others may work (Mac Safari does not work).\n  - The [new web editor is here](https://www.musicthing.co.uk/web_config/turing2.html) but if you access [the old editor](https://www.musicthing.co.uk/web_config/turing.html) it should redirect automatically.  \n  - What can you change in the editor? \n    - Scale: A choice of 7 scales / modes / not sure what they're techincally called\n    - Octave range: 1 - 4 Octaves\n    - Note length: This controls the pulses from Pulse 1 & 2 when the relevant notes start. Blip is  1% of the note length, or 2ms. There are two variable lengths, short and long, which are driven by their own Turing Machines, so they lock and randomise with the notes. \n    - Loop Length: Allows you to set Channel 2 as one step shorter, for uneven patterns. \n    - Pulse Mode 1 & 2: Clock outputs every clock pulse, Turing outputs on a clock pulse where bit 1 of the Turing machine sequence is 1. This is more or less the same as the 'Pulse' output on a hardware Turing Machine. \n    - Audio/CV Output Range: Sets the ranges for the top two outputs. \n\n- **New CV inputs**: \n  - CV In 1 = Diviply \n    - Accepts positive and negative values to speed up or slow down the divide / multiply rate on Channel 2. Try patching this to the CV/Audio outputs to get complicated rhythmic sequences.  \n  - CV In 2 = Offset \n    - Experimental: This takes a v/oct signal between 0v and 1v and applies that as an offset to both channels - CV1 and CV2 . It is not calibrated but is quantised to a chromatic scale. Let me know how you get on with it. \n  - Audio/CV 1 = Reset \n    - Experimental. Many sequencers have a reset button that jumps the sequence back to Step 1. Hardware Turing Machines never had this kind of reset input, because there's no easy way to step back to a previous state - the shift register that holds the binary sequence has moved on. If you send a pulse to this input (a rising edge) it will reset all the sequences back to their first step. Let me know if you find it interesting or useful. \n  - Audio/CV 2 = Switch \n    - Experimental: This input gives CV control over the switch to choose which preset is active. An input of +1v or more pushes the switch up, -1v or less pulls the switch down. \n\n\n## Tips: \n- Hold down the toggle switch and tap the reset/load button to clear the internal settings. When you see a fast animation on the LEDs it's safe to release the toggle switch. You may need to do this after updating the Program Card. \n\n## Behind the scenes: \n- The entire thing has been rewritten in Pico SDK C++ using [Chris Johnston's Computer Card library](https://github.com/TomWhitwell/Workshop_Computer/tree/main/Demonstrations%2BHelloWorlds/PicoSDK/ComputerCard). \n- One core runs at 48khz, tracking input pulses and updating the clocks. The second core handles LED updates, USB connection to the editor, and flash writes. \n\n## Quirks & not yes working: \n- Card version check / upgrade: At some point I'll move this card to it's own Repo, at which point upgrades will be shown automatically. \n- The visualiser in the web editor is slightly unscientific - clocked by both pulse outputs \n- The CSS on the web editor could be improved to make it responsive on different screen types. If you can help with that, please let me know. \n- Tiny delays in the main clock are noticeable a second after setting tap tempo and when making changes in the editor. If you can work out how to reduce those glitches please let me know. \n\n\n## Specific questions for testers \n- Any problems with different web editors? \n- How is external clocking? Any devices that don't work well? \n- Any glitches, points where the system becomes unresponsive? \n- Note lengths are proportional to divisions - so if the CV2/Pulse2 is running 4x faster than the main output, the pulses are 4 x shorter (to a minimum of 2ms. I'm not sure if this is the right behaviour \n- Adding or swapping scales for more useful ones is easy, I'm up for suggestions \n- Are the variable length pulses short and long the right durations / ranges? \n\n\n",
    "readme_html": "<h1 id=\"turing-machine-program-card-v15\">Turing Machine Program Card V1.5</h1>\n<p>Read these notes alongside the <a href=\"https://www.musicthing.co.uk/Computer_Program_Cards/#03-turing-machine\">previous version instructions</a></p>\n<h2 id=\"whats-new\">What&rsquo;s new</h2>\n<ul>\n<li><strong>Clock In</strong>: </li>\n<li>Send a clock to Pulse 1 and the tap tempo is replaced with the clock in. </li>\n<li>The clock <em>Diviply</em> function that drives Channel 2 will be driven by the external input clock, so can be used as a standalone clock divide/multiply. It&rsquo;s fairly simple - if the external clock changes speed, the diviply clock waits for a second pulse before changing speed itself. I found this more musical/pleasingly weird than attempting to average clock speed changes. </li>\n<li>This clock input works into high audio rate, turning the Turing Machine into a random wavetable oscillator. </li>\n<li>A clock into Pulse 2 overwrites the diviply clock, so you have two independently clocked Turing Machines. In this case Pulse Out 2 simply mirrors Pulse In 2. </li>\n<li><strong>New Editor</strong>: </li>\n<li>The web editor has been redesigned to emphasise the two presets accessed with the toggle switch. It now connects to the Workshop Computer using MIDI sysex, which seems more reliable and easier, once MIDI communication has been permitted. Once again, Chrome is the only browser that has been tested, although others may work (Mac Safari does not work).</li>\n<li>The <a href=\"https://www.musicthing.co.uk/web_config/turing2.html\">new web editor is here</a> but if you access <a href=\"https://www.musicthing.co.uk/web_config/turing.html\">the old editor</a> it should redirect automatically.  </li>\n<li>\n<p>What can you change in the editor? </p>\n<ul>\n<li>Scale: A choice of 7 scales / modes / not sure what they&rsquo;re techincally called</li>\n<li>Octave range: 1 - 4 Octaves</li>\n<li>Note length: This controls the pulses from Pulse 1 &amp; 2 when the relevant notes start. Blip is  1% of the note length, or 2ms. There are two variable lengths, short and long, which are driven by their own Turing Machines, so they lock and randomise with the notes. </li>\n<li>Loop Length: Allows you to set Channel 2 as one step shorter, for uneven patterns. </li>\n<li>Pulse Mode 1 &amp; 2: Clock outputs every clock pulse, Turing outputs on a clock pulse where bit 1 of the Turing machine sequence is 1. This is more or less the same as the &lsquo;Pulse&rsquo; output on a hardware Turing Machine. </li>\n<li>Audio/CV Output Range: Sets the ranges for the top two outputs. </li>\n</ul>\n</li>\n<li>\n<p><strong>New CV inputs</strong>: </p>\n</li>\n<li>CV In 1 = Diviply <ul>\n<li>Accepts positive and negative values to speed up or slow down the divide / multiply rate on Channel 2. Try patching this to the CV/Audio outputs to get complicated rhythmic sequences.  </li>\n</ul>\n</li>\n<li>CV In 2 = Offset <ul>\n<li>Experimental: This takes a v/oct signal between 0v and 1v and applies that as an offset to both channels - CV1 and CV2 . It is not calibrated but is quantised to a chromatic scale. Let me know how you get on with it. </li>\n</ul>\n</li>\n<li>Audio/CV 1 = Reset <ul>\n<li>Experimental. Many sequencers have a reset button that jumps the sequence back to Step 1. Hardware Turing Machines never had this kind of reset input, because there&rsquo;s no easy way to step back to a previous state - the shift register that holds the binary sequence has moved on. If you send a pulse to this input (a rising edge) it will reset all the sequences back to their first step. Let me know if you find it interesting or useful. </li>\n</ul>\n</li>\n<li>Audio/CV 2 = Switch <ul>\n<li>Experimental: This input gives CV control over the switch to choose which preset is active. An input of +1v or more pushes the switch up, -1v or less pulls the switch down. </li>\n</ul>\n</li>\n</ul>\n<h2 id=\"tips\">Tips:</h2>\n<ul>\n<li>Hold down the toggle switch and tap the reset/load button to clear the internal settings. When you see a fast animation on the LEDs it&rsquo;s safe to release the toggle switch. You may need to do this after updating the Program Card. </li>\n</ul>\n<h2 id=\"behind-the-scenes\">Behind the scenes:</h2>\n<ul>\n<li>The entire thing has been rewritten in Pico SDK C++ using <a href=\"https://github.com/TomWhitwell/Workshop_Computer/tree/main/Demonstrations%2BHelloWorlds/PicoSDK/ComputerCard\">Chris Johnston&rsquo;s Computer Card library</a>. </li>\n<li>One core runs at 48khz, tracking input pulses and updating the clocks. The second core handles LED updates, USB connection to the editor, and flash writes. </li>\n</ul>\n<h2 id=\"quirks-not-yes-working\">Quirks &amp; not yes working:</h2>\n<ul>\n<li>Card version check / upgrade: At some point I&rsquo;ll move this card to it&rsquo;s own Repo, at which point upgrades will be shown automatically. </li>\n<li>The visualiser in the web editor is slightly unscientific - clocked by both pulse outputs </li>\n<li>The CSS on the web editor could be improved to make it responsive on different screen types. If you can help with that, please let me know. </li>\n<li>Tiny delays in the main clock are noticeable a second after setting tap tempo and when making changes in the editor. If you can work out how to reduce those glitches please let me know. </li>\n</ul>\n<h2 id=\"specific-questions-for-testers\">Specific questions for testers</h2>\n<ul>\n<li>Any problems with different web editors? </li>\n<li>How is external clocking? Any devices that don&rsquo;t work well? </li>\n<li>Any glitches, points where the system becomes unresponsive? </li>\n<li>Note lengths are proportional to divisions - so if the CV2/Pulse2 is running 4x faster than the main output, the pulses are 4 x shorter (to a minimum of 2ms. I&rsquo;m not sure if this is the right behaviour </li>\n<li>Adding or swapping scales for more useful ones is easy, I&rsquo;m up for suggestions </li>\n<li>Are the variable length pulses short and long the right durations / ranges? </li>\n</ul>",
    "has_documentation": false,
    "has_firmware": true
  },
  {
    "id": "04_BYO_Benjolin",
    "number": "04",
    "title": "Byo Benjolin",
    "description": "Rungler, Chaotic VCO, Noise Source, Turing Machine, Quantizer",
    "language": "Pico SDK",
    "creator": "Dune Desormeaux",
    "version": "1.0",
    "status": "Released",
    "pdf_files": [
      "releases/04_BYO_Benjolin/Docs/BYO_Benjolin.pdf"
    ],
    "uf2_files": [
      "releases/04_BYO_Benjolin/UF2/byo_benjolin.uf2"
    ],
    "readme": "",
    "readme_html": "",
    "has_documentation": true,
    "has_firmware": true
  },
  {
    "id": "05_chord_blimey",
    "number": "05",
    "title": "Chord Blimey",
    "description": "Generates CV/Pulse arpeggios",
    "language": "C (RPi Pico SDK)",
    "creator": "Tom Waters",
    "version": "0.9",
    "status": "Mostly complete (for now)",
    "pdf_files": [
      "releases/05_chord_blimey/Documentation/05 Chord Blimey Card.pdf"
    ],
    "uf2_files": [
      "releases/05_chord_blimey/binaries/chord_blimey.uf2",
      "releases/05_chord_blimey/binaries/chord_blimey_orig.uf2"
    ],
    "readme": "# Chord Blimey!\n\n**Chord Blimey!** is an arpeggiator for the [Music Thing Modular Workshop Computer](https://www.musicthing.co.uk/workshopcomputer/) that generates arpeggios from selected chords, with multiple playback directions, configurable sequence length, and random CV outputs for extra patch variation.\n\n## Overview\n\nSend a trigger to the Workshop Computer and it outputs an arpeggiated chord on **CV Out 1**, with a matching trigger on **Pulse Out 1** for each note.  \nWhen the full arpeggio cycle ends, **Pulse Out 2** fires so you can chain or loop sequences.\n\nYou can control **root pitch**, **chord type**, **speed**, **sequence length**, and **arpeggiator direction** using the Workshop Computer’s knobs, CV inputs, and toggle switch.  \n\nRandom voltages on **Audio Out 1 & 2** change probabilistically at the end of each chord, for modulation sources.\n\n---\n\n## Inputs & Outputs\n\n| Jack / Control | Function |\n|----------------|----------|\n| **Pulse In 1** | Starts the arpeggio when triggered. If patched from Pulse Out 2, the arpeggio will loop. |\n| **Pulse In 2** | Not used in this program. |\n| **CV In 1**    | Adds to the root note (in volts). 1V = 1 octave. |\n| **CV In 2**    | Adds to the chord selection (0–1V range). |\n| **CV Out 1**   | Current note of the arpeggio (root + chord degree). |\n| **CV Out 2**   | Root note of the chord (constant for the duration of the chord). |\n| **Pulse Out 1**| Fires for each note in the arpeggio. |\n| **Pulse Out 2**| Fires when the last note of the arpeggio plays (also at startup). |\n| **Audio Out 1**| Random voltage 0–1V (changes at chord end). |\n| **Audio Out 2**| Random voltage 0–1V (changes at chord end). |\n\n---\n\n## Controls\n\n| Control | Function |\n|---------|----------|\n| **Big Knob (Z Pot)** | Controls arpeggio speed (note length). Faster at higher settings. |\n| **X Knob (X Pot)**   | Controls root note in volts (0–1V) — combined with CV In 1. |\n| **Y Knob (Y Pot)**   | Selects chord type — combined with CV In 2. |\n| **3-position toggle switch** | **UP**: Full-length mode (all chord notes).<br>**MID**: Fixed-length mode (limits to selected number of steps).<br>**DOWN**: Short press cycles fixed-length number (1–6 steps). Long press changes arpeggiator direction. |\n| **LEDs** | Show current step in sequence during playback. Also flash a pattern when arpeggiator direction changes, or when fixed-length is adjusted. |\n\n---\n\n## Arpeggiator Modes\n\nLong-press the toggle switch in the **DOWN** position to cycle through modes.  \nLEDs briefly show a pattern for the selected mode.\n\n1. **Up** – Ascend through notes.\n2. **Down** – Descend through notes.\n3. **Up-Up** – Ascend, playing each note twice.\n4. **Down-Down** – Descend, playing each note twice.\n5. **Up-Down Inclusive** – Ascend then descend, repeating the highest note.  \n   Example (degrees): `0, 1, 3, 5, 5, 3, 1, 0`\n6. **Up-Down Exclusive** – Ascend then descend, skipping repeats at both ends.  \n   Example (degrees): `0, 1, 3, 5, 3, 1`\n\nWhen in fixed-length mode, these modes still respect the step count — extra notes are generated by octave jumps if needed.\n\n---\n\n## Sequence Length\n\n- In **MID** position, the number of steps is fixed (1–6).\n- Short press the toggle in **DOWN** position to increase step count (wraps around after 6).\n- If the chord has fewer notes than the selected steps, higher octaves are added automatically.\n\n---\n\n## Random Outputs\n\n- **Audio Out 1 & 2** output random voltages 0–1V.\n- They change **only at the end of a chord**.\n- The probability of change starts low and increases each time until a change happens, then resets.\n\n---\n\n## End-of-Arpeggio Output\n\n**Pulse Out 2** always fires at the end of an arpeggio cycle.  \nThis can be used to:\n- Trigger another module at phrase boundaries.\n- Feed back into **Pulse In 1** for self-looping arpeggios.\n\n---\n\n## Typical Patch Example\n\n1. Patch **Pulse Out 2 → Pulse In 1** to make the arp self-loop.\n2. Patch **CV Out 1** to a VCO’s pitch input.\n3. Patch **Pulse Out 1** to your VCA or envelope.\n4. Use **X/Y knobs** (or CV In 1/2) to choose key and chord.\n5. Use **Z knob** to set note speed.\n6. Use toggle and short/long presses to set step length and arpeggiator mode.\n7. Optionally, send **Audio Out 1/2** to modulate filters, LFO rates, etc.",
    "readme_html": "<h1 id=\"chord-blimey\">Chord Blimey!</h1>\n<p><strong>Chord Blimey!</strong> is an arpeggiator for the <a href=\"https://www.musicthing.co.uk/workshopcomputer/\">Music Thing Modular Workshop Computer</a> that generates arpeggios from selected chords, with multiple playback directions, configurable sequence length, and random CV outputs for extra patch variation.</p>\n<h2 id=\"overview\">Overview</h2>\n<p>Send a trigger to the Workshop Computer and it outputs an arpeggiated chord on <strong>CV Out 1</strong>, with a matching trigger on <strong>Pulse Out 1</strong> for each note.<br />\nWhen the full arpeggio cycle ends, <strong>Pulse Out 2</strong> fires so you can chain or loop sequences.</p>\n<p>You can control <strong>root pitch</strong>, <strong>chord type</strong>, <strong>speed</strong>, <strong>sequence length</strong>, and <strong>arpeggiator direction</strong> using the Workshop Computer’s knobs, CV inputs, and toggle switch.  </p>\n<p>Random voltages on <strong>Audio Out 1 &amp; 2</strong> change probabilistically at the end of each chord, for modulation sources.</p>\n<hr />\n<h2 id=\"inputs-outputs\">Inputs &amp; Outputs</h2>\n<table>\n<thead>\n<tr>\n<th>Jack / Control</th>\n<th>Function</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>Pulse In 1</strong></td>\n<td>Starts the arpeggio when triggered. If patched from Pulse Out 2, the arpeggio will loop.</td>\n</tr>\n<tr>\n<td><strong>Pulse In 2</strong></td>\n<td>Not used in this program.</td>\n</tr>\n<tr>\n<td><strong>CV In 1</strong></td>\n<td>Adds to the root note (in volts). 1V = 1 octave.</td>\n</tr>\n<tr>\n<td><strong>CV In 2</strong></td>\n<td>Adds to the chord selection (0–1V range).</td>\n</tr>\n<tr>\n<td><strong>CV Out 1</strong></td>\n<td>Current note of the arpeggio (root + chord degree).</td>\n</tr>\n<tr>\n<td><strong>CV Out 2</strong></td>\n<td>Root note of the chord (constant for the duration of the chord).</td>\n</tr>\n<tr>\n<td><strong>Pulse Out 1</strong></td>\n<td>Fires for each note in the arpeggio.</td>\n</tr>\n<tr>\n<td><strong>Pulse Out 2</strong></td>\n<td>Fires when the last note of the arpeggio plays (also at startup).</td>\n</tr>\n<tr>\n<td><strong>Audio Out 1</strong></td>\n<td>Random voltage 0–1V (changes at chord end).</td>\n</tr>\n<tr>\n<td><strong>Audio Out 2</strong></td>\n<td>Random voltage 0–1V (changes at chord end).</td>\n</tr>\n</tbody>\n</table>\n<hr />\n<h2 id=\"controls\">Controls</h2>\n<table>\n<thead>\n<tr>\n<th>Control</th>\n<th>Function</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>Big Knob (Z Pot)</strong></td>\n<td>Controls arpeggio speed (note length). Faster at higher settings.</td>\n</tr>\n<tr>\n<td><strong>X Knob (X Pot)</strong></td>\n<td>Controls root note in volts (0–1V) — combined with CV In 1.</td>\n</tr>\n<tr>\n<td><strong>Y Knob (Y Pot)</strong></td>\n<td>Selects chord type — combined with CV In 2.</td>\n</tr>\n<tr>\n<td><strong>3-position toggle switch</strong></td>\n<td><strong>UP</strong>: Full-length mode (all chord notes).<br><strong>MID</strong>: Fixed-length mode (limits to selected number of steps).<br><strong>DOWN</strong>: Short press cycles fixed-length number (1–6 steps). Long press changes arpeggiator direction.</td>\n</tr>\n<tr>\n<td><strong>LEDs</strong></td>\n<td>Show current step in sequence during playback. Also flash a pattern when arpeggiator direction changes, or when fixed-length is adjusted.</td>\n</tr>\n</tbody>\n</table>\n<hr />\n<h2 id=\"arpeggiator-modes\">Arpeggiator Modes</h2>\n<p>Long-press the toggle switch in the <strong>DOWN</strong> position to cycle through modes.<br />\nLEDs briefly show a pattern for the selected mode.</p>\n<ol>\n<li><strong>Up</strong> – Ascend through notes.</li>\n<li><strong>Down</strong> – Descend through notes.</li>\n<li><strong>Up-Up</strong> – Ascend, playing each note twice.</li>\n<li><strong>Down-Down</strong> – Descend, playing each note twice.</li>\n<li><strong>Up-Down Inclusive</strong> – Ascend then descend, repeating the highest note.<br />\n   Example (degrees): <code>0, 1, 3, 5, 5, 3, 1, 0</code></li>\n<li><strong>Up-Down Exclusive</strong> – Ascend then descend, skipping repeats at both ends.<br />\n   Example (degrees): <code>0, 1, 3, 5, 3, 1</code></li>\n</ol>\n<p>When in fixed-length mode, these modes still respect the step count — extra notes are generated by octave jumps if needed.</p>\n<hr />\n<h2 id=\"sequence-length\">Sequence Length</h2>\n<ul>\n<li>In <strong>MID</strong> position, the number of steps is fixed (1–6).</li>\n<li>Short press the toggle in <strong>DOWN</strong> position to increase step count (wraps around after 6).</li>\n<li>If the chord has fewer notes than the selected steps, higher octaves are added automatically.</li>\n</ul>\n<hr />\n<h2 id=\"random-outputs\">Random Outputs</h2>\n<ul>\n<li><strong>Audio Out 1 &amp; 2</strong> output random voltages 0–1V.</li>\n<li>They change <strong>only at the end of a chord</strong>.</li>\n<li>The probability of change starts low and increases each time until a change happens, then resets.</li>\n</ul>\n<hr />\n<h2 id=\"end-of-arpeggio-output\">End-of-Arpeggio Output</h2>\n<p><strong>Pulse Out 2</strong> always fires at the end of an arpeggio cycle.<br />\nThis can be used to:\n- Trigger another module at phrase boundaries.\n- Feed back into <strong>Pulse In 1</strong> for self-looping arpeggios.</p>\n<hr />\n<h2 id=\"typical-patch-example\">Typical Patch Example</h2>\n<ol>\n<li>Patch <strong>Pulse Out 2 → Pulse In 1</strong> to make the arp self-loop.</li>\n<li>Patch <strong>CV Out 1</strong> to a VCO’s pitch input.</li>\n<li>Patch <strong>Pulse Out 1</strong> to your VCA or envelope.</li>\n<li>Use <strong>X/Y knobs</strong> (or CV In 1/2) to choose key and chord.</li>\n<li>Use <strong>Z knob</strong> to set note speed.</li>\n<li>Use toggle and short/long presses to set step length and arpeggiator mode.</li>\n<li>Optionally, send <strong>Audio Out 1/2</strong> to modulate filters, LFO rates, etc.</li>\n</ol>",
    "has_documentation": true,
    "has_firmware": true
  },
  {
    "id": "06_usb_audio",
    "number": "06",
    "title": "Usb Audio",
    "description": "USB audio output",
    "language": "C (RPi Pico SDK)",
    "creator": "Chris Johnson",
    "version": "0.1",
    "status": "Proof of concept",
    "pdf_files": [],
    "uf2_files": [
      "releases/06_usb_audio/build/usb_audio_interface.uf2"
    ],
    "readme": "# USB Audio\n\nUSB audio output for Music Thing Modular Workshop Computer\n\n48kHz 16-bit stereo input through USB\n\n12-bit output through both audio out jacks.\n\nMain knob controls volume:\n- Knob at 12 o'clock is the default value (0dB amplification).\n- This volume and quieter will not introduce clipping \n- Louder volumes may clip but could be useful for boosting quiet sources\n\n\nHeavily based on the [Pico-USB-Audio project](https://github.com/tierneytim/Pico-USB-audio/) project by Tim Tierney, with modifications only to: \n- use MTM Computer DAC and knob\n- to convert to 48kHz stereo.\n\n#### Compiling from source\n\nThe source is in C, using the Raspberry Pi Pico SDK. To compile:\n\n1. Copy the custom board definition `mtm_computer_16mb.h` to `<path_to_pico_sdk>/src/boards/include/boards/`. \n\n2. Set up the environment variable defining the path to the Pico SDK, e.g.:\n    `export PICO_SDK_PATH=<path_to_pico_sdk>`\n\tor equivalent for your shell.\n    \n3. Change to `06_usb_audio/` directory\n\n4. Make and build in the usual way for the Pico SDK:\n\n\n    mkdir build\n    cd build\n    cmake ..\n    make\n    \n\n(The custom board definition  defines `#define PICO_XOSC_STARTUP_DELAY_MULTIPLIER 64`,  often needed for the RP2040 to startup).\n   \n   \n   \n----\n\nThis code is a modification of the [Pico-USB-Audio project](https://github.com/tierneytim/Pico-USB-audio/) by Tim Tierney\n\nAdapted for Music Thing Modular Workshop Computer by [Chris Johnson](https://github.com/chrisgjohnson)\n",
    "readme_html": "<h1 id=\"usb-audio\">USB Audio</h1>\n<p>USB audio output for Music Thing Modular Workshop Computer</p>\n<p>48kHz 16-bit stereo input through USB</p>\n<p>12-bit output through both audio out jacks.</p>\n<p>Main knob controls volume:\n- Knob at 12 o&rsquo;clock is the default value (0dB amplification).\n- This volume and quieter will not introduce clipping \n- Louder volumes may clip but could be useful for boosting quiet sources</p>\n<p>Heavily based on the <a href=\"https://github.com/tierneytim/Pico-USB-audio/\">Pico-USB-Audio project</a> project by Tim Tierney, with modifications only to: \n- use MTM Computer DAC and knob\n- to convert to 48kHz stereo.</p>\n<h4 id=\"compiling-from-source\">Compiling from source</h4>\n<p>The source is in C, using the Raspberry Pi Pico SDK. To compile:</p>\n<ol>\n<li>\n<p>Copy the custom board definition <code>mtm_computer_16mb.h</code> to <code>&lt;path_to_pico_sdk&gt;/src/boards/include/boards/</code>. </p>\n</li>\n<li>\n<p>Set up the environment variable defining the path to the Pico SDK, e.g.:\n    <code>export PICO_SDK_PATH=&lt;path_to_pico_sdk&gt;</code>\n    or equivalent for your shell.</p>\n</li>\n<li>\n<p>Change to <code>06_usb_audio/</code> directory</p>\n</li>\n<li>\n<p>Make and build in the usual way for the Pico SDK:</p>\n<p>mkdir build\ncd build\ncmake ..\nmake</p>\n</li>\n</ol>\n<p>(The custom board definition  defines <code>#define PICO_XOSC_STARTUP_DELAY_MULTIPLIER 64</code>,  often needed for the RP2040 to startup).</p>\n<hr />\n<p>This code is a modification of the <a href=\"https://github.com/tierneytim/Pico-USB-audio/\">Pico-USB-Audio project</a> by Tim Tierney</p>\n<p>Adapted for Music Thing Modular Workshop Computer by <a href=\"https://github.com/chrisgjohnson\">Chris Johnson</a></p>",
    "has_documentation": false,
    "has_firmware": true
  },
  {
    "id": "07_bumpers",
    "number": "07",
    "title": "Bumpers",
    "description": "Synth bumpers",
    "language": "C++ (ComputerCard)",
    "creator": "Chris Johnson",
    "version": "1.0",
    "status": "Released",
    "pdf_files": [
      "releases/07_bumpers/synth_bumpers.pdf"
    ],
    "uf2_files": [
      "releases/07_bumpers/build/bumpers.uf2"
    ],
    "readme": "# Synth bumpers\n\nA bouncing-ball trigger and multitap delay card for the Music Thing Modular Workshop System Computer\n\nSee [`build/bumpers.uf2`](./build/bumpers.uf2) for the prebuilt binary, and [`synth_bumpers.pdf`](./synth_bumpers.pdf) for the documentation booklet (print and fold).\n\n### Demo video:\n<div align=\"left\">\n      <a href=\"https://youtube.com/watch/?v=MvxuzqFLGJM\">\n         <img src=\"https://i.ytimg.com/vi_webp/MvxuzqFLGJM/maxresdefault.webp\" style=\"width:400px\">\n      </a>\n</div>\n",
    "readme_html": "<h1 id=\"synth-bumpers\">Synth bumpers</h1>\n<p>A bouncing-ball trigger and multitap delay card for the Music Thing Modular Workshop System Computer</p>\n<p>See <a href=\"./build/bumpers.uf2\"><code>build/bumpers.uf2</code></a> for the prebuilt binary, and <a href=\"./synth_bumpers.pdf\"><code>synth_bumpers.pdf</code></a> for the documentation booklet (print and fold).</p>\n<h3 id=\"demo-video\">Demo video:</h3>\n<div align=\"left\">\n      <a href=\"https://youtube.com/watch/?v=MvxuzqFLGJM\">\n         <img src=\"https://i.ytimg.com/vi_webp/MvxuzqFLGJM/maxresdefault.webp\" style=\"width:400px\">\n      </a>\n</div>",
    "has_documentation": true,
    "has_firmware": true
  },
  {
    "id": "08_bytebeat",
    "number": "08",
    "title": "Bytebeat",
    "description": "Generates and mangles bytebeats",
    "language": "C++/Arduino-Pico",
    "creator": "Matt Kuebrich",
    "version": "0.1",
    "status": "Functional but WIP",
    "pdf_files": [],
    "uf2_files": [
      "releases/08_bytebeat/uf2 Installer/08_bytebeat.ino.uf2"
    ],
    "readme": "# 08 - bytebeat\n\nA program for generating and mangling <a href=\"http://canonical.org/~kragen/bytebeat/\">bytebeats</a>.\n\nThere are 36 built-in bytebeat formulas organized into 6 banks of 6, which are indicated by the LEDs. The last 2 banks contain percussive/drum sounds which need to be triggered with Pulse In 1. \n\nBytebeats can also be \"live-coded\" through the web interface (bytebeat.html) and saved to 6 \"user\" slots on the card.\n\nFlash this program via [Arudino IDE](https://www.arduino.cc/en/software/) using [earlephilhower's Raspberry Pi Pico Arduino core](https://github.com/earlephilhower/arduino-pico) or use the pre-built UF2. \n\nThis is written for the Proto 1.2 (May 2024) Developer Kit.\n\n##  Controls \n\n  - Main Pot = Sample Rate (Speed)\n  - Pot X = Bank/Formula Select\n  - Pot Y = Parameter 1\n  - Switch Z Up = Built-in Formulas\n  - Switch Z Middle = User Formulas\n  - Switch Z Down (momentary) = Reset / Trigger\n  \n ##  Inputs\n\n- Audio In 1 = Parameter 1 Modulation\n- Audio In 2 = Parameter 2 Modulation \n- CV In 1 = Formula Select Modulation \n- CV In 2 = Sample Rate Modulation\n- Pulse In 1 = Reset / Trigger\n- Pulse In 2 = Reverse\n\n##  Outputs\n\n- Audio Out 1 = Bytebeat Out\n- Audio Out 2 = Next Bytebeat Out\n- CV Out 1 = ByteBeat Out (Slow)\n- CV Out 2 = ByteBeat Out (Fast)\n- Pulse Out 1 = 1Bit Output (Bitbeat)\n- Pulse Out 2 = Division of ``t`` (Use as clock for other modules?)\n\n\n----\nAuthor: [Matt Kuebrich](https://github.com/MattKuebrich)\n\n",
    "readme_html": "<h1 id=\"08-bytebeat\">08 - bytebeat</h1>\n<p>A program for generating and mangling <a href=\"http://canonical.org/~kragen/bytebeat/\">bytebeats</a>.</p>\n<p>There are 36 built-in bytebeat formulas organized into 6 banks of 6, which are indicated by the LEDs. The last 2 banks contain percussive/drum sounds which need to be triggered with Pulse In 1. </p>\n<p>Bytebeats can also be &ldquo;live-coded&rdquo; through the web interface (bytebeat.html) and saved to 6 &ldquo;user&rdquo; slots on the card.</p>\n<p>Flash this program via <a href=\"https://www.arduino.cc/en/software/\">Arudino IDE</a> using <a href=\"https://github.com/earlephilhower/arduino-pico\">earlephilhower&rsquo;s Raspberry Pi Pico Arduino core</a> or use the pre-built UF2. </p>\n<p>This is written for the Proto 1.2 (May 2024) Developer Kit.</p>\n<h2 id=\"controls\">Controls</h2>\n<ul>\n<li>Main Pot = Sample Rate (Speed)</li>\n<li>Pot X = Bank/Formula Select</li>\n<li>Pot Y = Parameter 1</li>\n<li>Switch Z Up = Built-in Formulas</li>\n<li>Switch Z Middle = User Formulas</li>\n<li>Switch Z Down (momentary) = Reset / Trigger</li>\n</ul>\n<p>##  Inputs</p>\n<ul>\n<li>Audio In 1 = Parameter 1 Modulation</li>\n<li>Audio In 2 = Parameter 2 Modulation </li>\n<li>CV In 1 = Formula Select Modulation </li>\n<li>CV In 2 = Sample Rate Modulation</li>\n<li>Pulse In 1 = Reset / Trigger</li>\n<li>Pulse In 2 = Reverse</li>\n</ul>\n<h2 id=\"outputs\">Outputs</h2>\n<ul>\n<li>Audio Out 1 = Bytebeat Out</li>\n<li>Audio Out 2 = Next Bytebeat Out</li>\n<li>CV Out 1 = ByteBeat Out (Slow)</li>\n<li>CV Out 2 = ByteBeat Out (Fast)</li>\n<li>Pulse Out 1 = 1Bit Output (Bitbeat)</li>\n<li>Pulse Out 2 = Division of <code>t</code> (Use as clock for other modules?)</li>\n</ul>\n<hr />\n<p>Author: <a href=\"https://github.com/MattKuebrich\">Matt Kuebrich</a></p>",
    "has_documentation": false,
    "has_firmware": true
  },
  {
    "id": "10_twists",
    "number": "10",
    "title": "Twists",
    "description": "A port of Mutable Instruments Braids with a web editor",
    "language": "C (RPi Pico SDK)",
    "creator": "Random Works",
    "version": "0.1",
    "status": "Functional but WIP",
    "pdf_files": [
      "releases/10_twists/10 Twists Card.pdf"
    ],
    "uf2_files": [
      "releases/10_twists/uf2 Installer/twists.uf2"
    ],
    "readme": "# twists\n\nA port of Mutable Instruments Braids to the Music Thing Modular Computer\n\nCode is almost entirely Emilie Gillet's Braids\\\nADC Interrupt code & Web MIDI config is almost entirely copied from Chris Johnson's Reverb release\\\nAnything else - Tom Waters\n\n## Usage\nOutput - Audio Out 1\\\nPitch - CV In 1 and/or the big knob\\\nTrigger - Pulse In 1\\\n\nTimbre - X knob\\\nColor - Y knob\\\n\nToggle the switch down to switch between six oscilator shapes\\\nConnect over USB and use twists.html to set the six available shapes\n",
    "readme_html": "<h1 id=\"twists\">twists</h1>\n<p>A port of Mutable Instruments Braids to the Music Thing Modular Computer</p>\n<p>Code is almost entirely Emilie Gillet&rsquo;s Braids\\\nADC Interrupt code &amp; Web MIDI config is almost entirely copied from Chris Johnson&rsquo;s Reverb release\\\nAnything else - Tom Waters</p>\n<h2 id=\"usage\">Usage</h2>\n<p>Output - Audio Out 1\\\nPitch - CV In 1 and/or the big knob\\\nTrigger - Pulse In 1\\</p>\n<p>Timbre - X knob\\\nColor - Y knob\\</p>\n<p>Toggle the switch down to switch between six oscilator shapes\\\nConnect over USB and use twists.html to set the six available shapes</p>",
    "has_documentation": true,
    "has_firmware": true
  },
  {
    "id": "11_goldfish",
    "number": "11",
    "title": "Goldfish",
    "description": "Weird delay/looper for audio and CV",
    "language": "Pico SDK",
    "creator": "Dune Desormeaux",
    "version": "1.0",
    "status": "Ready",
    "pdf_files": [
      "releases/11_goldfish/Documentation/Goldfish_Docs.pdf"
    ],
    "uf2_files": [
      "releases/11_goldfish/UF2/goldfish.uf2"
    ],
    "readme": "",
    "readme_html": "",
    "has_documentation": true,
    "has_firmware": true
  },
  {
    "id": "12_am_coupler",
    "number": "12",
    "title": "Am Coupler",
    "description": "AM radio transmitter / coupler",
    "language": "C++ / ComputerCard / RPi Pico SDK",
    "creator": "Chris Johnson",
    "version": "1.0",
    "status": "Released",
    "pdf_files": [],
    "uf2_files": [
      "releases/12_am_coupler/build/am_coupler.uf2"
    ],
    "readme": "# AM Coupler\n\n*AM Coupler* is a card that allows audio from the Workshop System to be received by an AM radio.\n\n\nAM Coupler generates a radio frequency (RF) carrier wave in the Medium Wave band (530–1600kHz) and modulates this with an audio signal.\n\nBecause the output jacks of the Computer are not designed to generate frequencies much higher than audio, the RF output is generated on one of the debug connections, next to the LEDs on the Computer PCB. A short length of insulated wire connected to this and held next to to the antenna of an AM radio receiver, will, with some tuning, transfer the sound to the radio.\n\nThe RF output of this card is a simple unfiltered PWM signal, containing appreciable harmonics up to several hundred MHz, which can be radiated very effectively by a short piece of  wire. **This card therefore has the potential to broadcast radio interference over a wide range of frequencies.**  Additional filtering and attenuation may well be needed to ensure that radio emissions are within legal limits.\n\n### Hardware requirements:\n\nWith a radio antenna very close to the bottom-left corner of the Workshop System, you may be able to pick up signals with no additional hardware. Most likely, a short length of wire will be needed, attached to the UART TX connection of the Workshop System Computer PCB. When attaching a wire to this, be extremely careful not to create a short between this and the the adjacent LED pin, as doing this and turning on power is likely to destroy the Computer module. I soldered a ~5cm wire with attached female pin header (blue wire in the photo below), to which a longer stretch of wire can be added when in use.\n\n<img src=\"docs/txpin.jpg\"><img src=\"docs/soldering.jpg\"><img src=\"docs/grounding.jpg\">\n\nDepending on the power supply used, additional grounding of the Workshop System can reduce noise.\n\n### Quick start:\n1. Attach a ~50cm wire to the UART TX pin as detailed above, and place this immediately adjacent to the antenna of a radio set to receive Medium Wave. Tune the radio so that is 'between stations'.\n2. Plug an audio signal (from one of the SineSquare oscillators, say) into Audio Input 1, and move the switch to the up position to turn on the radio signal. \n3. Use Main Knob to adjust the transmitted frequency, until you hear something on the radio\n\n\n### Controls:\n\n* **Switch + Pulse In 1:** RF carrier on/off\n    * Middle position: RF carrier off\n    * Top or bottom position: RF carrier on\n        * If there is jack in Pulse In 1, then the RF carrier is turned on only when Pulse In 1 is high. \n* **Main Knob:** Coarse RF carrier tuning, roughly from 530–1600kHz\n* **Knob X + CV input 1:** Fine RF carrier tuning, over roughly 25kHz\n* **Knob Y:** Broadcast volume (carrier modulation amount)\n* **Audio inputs 1 & 2**: Mixed to provide the RF modulator signal. \n    * If no jack is connected to either input, then a stored WAV file is used as the RF modulator (see below).\n* **Audio output 1**: Outputs the stored WAV file (regardless of whether there are jacks in the audio inputs)\n* **Audio output 2**: Outputs the modulation signal\n\n\n* **Top left LED:** lit to indicate RF carrier on\n* **Right LEDs:** three LEDs show 'VU meter' for carrier modulation amount\n\n### WAV file playback:\nThis card supports storage and playback of a WAV file, using the same interface as the `sample_upload` example of ComputerCard. If no jack is connected to either audio input, then the WAV file is used as the modulator signal. \n\n\n### Tips:\n\n* It is intended that the antenna of the radio receiver is immediately adjacent to the Workshop System. Transmission range and audio quality is highly dependent on conditions, antenna length and position, and frequency. I've generally found higher frequencies give longer range - up to a couple of metres with a 50cm wire attached to the Workshop System and a cheap radio receiver. Without appropriate filtering, broadband interference of radio signals propagates much further and is easily detectable 10m away.\n* The main knob covers a similar range to the MW band on a radio receiver (530–1600kHz). If the main knob is near its anticlockwise stop, make sure the receiver is tuned to the fundamental frequency, and not its first (or even second) harmonic, which will also be towards the upper and of the MW band. \n",
    "readme_html": "<h1 id=\"am-coupler\">AM Coupler</h1>\n<p><em>AM Coupler</em> is a card that allows audio from the Workshop System to be received by an AM radio.</p>\n<p>AM Coupler generates a radio frequency (RF) carrier wave in the Medium Wave band (530–1600kHz) and modulates this with an audio signal.</p>\n<p>Because the output jacks of the Computer are not designed to generate frequencies much higher than audio, the RF output is generated on one of the debug connections, next to the LEDs on the Computer PCB. A short length of insulated wire connected to this and held next to to the antenna of an AM radio receiver, will, with some tuning, transfer the sound to the radio.</p>\n<p>The RF output of this card is a simple unfiltered PWM signal, containing appreciable harmonics up to several hundred MHz, which can be radiated very effectively by a short piece of  wire. <strong>This card therefore has the potential to broadcast radio interference over a wide range of frequencies.</strong>  Additional filtering and attenuation may well be needed to ensure that radio emissions are within legal limits.</p>\n<h3 id=\"hardware-requirements\">Hardware requirements:</h3>\n<p>With a radio antenna very close to the bottom-left corner of the Workshop System, you may be able to pick up signals with no additional hardware. Most likely, a short length of wire will be needed, attached to the UART TX connection of the Workshop System Computer PCB. When attaching a wire to this, be extremely careful not to create a short between this and the the adjacent LED pin, as doing this and turning on power is likely to destroy the Computer module. I soldered a ~5cm wire with attached female pin header (blue wire in the photo below), to which a longer stretch of wire can be added when in use.</p>\n<p><img src=\"docs/txpin.jpg\"><img src=\"docs/soldering.jpg\"><img src=\"docs/grounding.jpg\"></p>\n<p>Depending on the power supply used, additional grounding of the Workshop System can reduce noise.</p>\n<h3 id=\"quick-start\">Quick start:</h3>\n<ol>\n<li>Attach a ~50cm wire to the UART TX pin as detailed above, and place this immediately adjacent to the antenna of a radio set to receive Medium Wave. Tune the radio so that is &lsquo;between stations&rsquo;.</li>\n<li>Plug an audio signal (from one of the SineSquare oscillators, say) into Audio Input 1, and move the switch to the up position to turn on the radio signal. </li>\n<li>Use Main Knob to adjust the transmitted frequency, until you hear something on the radio</li>\n</ol>\n<h3 id=\"controls\">Controls:</h3>\n<ul>\n<li><strong>Switch + Pulse In 1:</strong> RF carrier on/off<ul>\n<li>Middle position: RF carrier off</li>\n<li>Top or bottom position: RF carrier on<ul>\n<li>If there is jack in Pulse In 1, then the RF carrier is turned on only when Pulse In 1 is high. </li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>Main Knob:</strong> Coarse RF carrier tuning, roughly from 530–1600kHz</li>\n<li><strong>Knob X + CV input 1:</strong> Fine RF carrier tuning, over roughly 25kHz</li>\n<li><strong>Knob Y:</strong> Broadcast volume (carrier modulation amount)</li>\n<li><strong>Audio inputs 1 &amp; 2</strong>: Mixed to provide the RF modulator signal. <ul>\n<li>If no jack is connected to either input, then a stored WAV file is used as the RF modulator (see below).</li>\n</ul>\n</li>\n<li><strong>Audio output 1</strong>: Outputs the stored WAV file (regardless of whether there are jacks in the audio inputs)</li>\n<li>\n<p><strong>Audio output 2</strong>: Outputs the modulation signal</p>\n</li>\n<li>\n<p><strong>Top left LED:</strong> lit to indicate RF carrier on</p>\n</li>\n<li><strong>Right LEDs:</strong> three LEDs show &lsquo;VU meter&rsquo; for carrier modulation amount</li>\n</ul>\n<h3 id=\"wav-file-playback\">WAV file playback:</h3>\n<p>This card supports storage and playback of a WAV file, using the same interface as the <code>sample_upload</code> example of ComputerCard. If no jack is connected to either audio input, then the WAV file is used as the modulator signal. </p>\n<h3 id=\"tips\">Tips:</h3>\n<ul>\n<li>It is intended that the antenna of the radio receiver is immediately adjacent to the Workshop System. Transmission range and audio quality is highly dependent on conditions, antenna length and position, and frequency. I&rsquo;ve generally found higher frequencies give longer range - up to a couple of metres with a 50cm wire attached to the Workshop System and a cheap radio receiver. Without appropriate filtering, broadband interference of radio signals propagates much further and is easily detectable 10m away.</li>\n<li>The main knob covers a similar range to the MW band on a radio receiver (530–1600kHz). If the main knob is near its anticlockwise stop, make sure the receiver is tuned to the fundamental frequency, and not its first (or even second) harmonic, which will also be towards the upper and of the MW band. </li>\n</ul>",
    "has_documentation": false,
    "has_firmware": true
  },
  {
    "id": "13_noisebox",
    "number": "13",
    "title": "Noisebox",
    "description": "",
    "language": "",
    "creator": "",
    "version": "",
    "status": "",
    "pdf_files": [],
    "uf2_files": [
      "releases/13_noisebox/13_noisebox.uf2"
    ],
    "readme": "# 13 Noisebox\n\n<img width=\"615\" height=\"1653\" alt=\"noisecard\" src=\"https://github.com/user-attachments/assets/c455c2f0-8165-4350-8eac-9da56125c553\" />\n\nMy first card! A port of 13 Befaco Noise Plethora algorithms (some of which are not 1:1, which might just be part of the charm, so don't expect them to sound exactly the same, it's noise!)\n\n**Main Knob:** Controls which algorithm you are currently selecting.\n\n**X & Y** Controls various parameters of the algorithm for sound shaping. X usually maps more closely to pitch but it varies.\n\n**Z**: Up toggles on a bitcrushing effect for crunchier noise. Middle is default, no effects.\n\nThe momentary toggle down randomizes all your controls - it lets you quickly get a new noise sound when you tap it and your controls now will all be offset.\n\nHold the momentary switch for over 2.5 seconds to reset this.\n\nINS:\n\n**CV In 1**: Offset CV for the algorithm being selected.\n\n**CV In 2**: VCA - you can gate your noise with this. Also great for AM modulation of the noise. With nothing plugged in, this normalizes to always being on.\n\n**CV In 3**: Offset CV for X Knob\n\n**CV In 4**: Offset CV for Y Knob\n\n**Pulse (CV In 5)**: Sample and Hold trigger (to be detailed further below)\n\n**Pulse (CV In 6)**: Gate to turn on and off the bitcrushing effect. Effect is on when input is high.\n\nOUTS:\n\n**CV Out 1/CV Out 2**: Output of the noise algorithm and its current parameters. Both outs have the same source. I may consider making CV Out 2 go through a rainbow of noise instead.\n\n**CV Out 3:** Output of the currently sample and held value, as determined by Pulse/CV In 5 - captures the current noise sample and holds until it receives another trigger.\n\n**CV Out 4**: Slewed output of the above. Slew time is determined by the time between pulses in **CV In 5**\n\n**Pulse/CV Out 5**: A binary gate toggled on or off if the sample and held value is greater than 0. Good for random gate patterns. Again this requires a clock or some signal into Pulse/CV In 5\n\n**Pulse/CV Out 6**: Realtime comparator signal from whether or not the noise sample is above 0. Really glitchy PWM sound.\n\n\n",
    "readme_html": "<h1 id=\"13-noisebox\">13 Noisebox</h1>\n<p><img width=\"615\" height=\"1653\" alt=\"noisecard\" src=\"https://github.com/user-attachments/assets/c455c2f0-8165-4350-8eac-9da56125c553\" /></p>\n<p>My first card! A port of 13 Befaco Noise Plethora algorithms (some of which are not 1:1, which might just be part of the charm, so don&rsquo;t expect them to sound exactly the same, it&rsquo;s noise!)</p>\n<p><strong>Main Knob:</strong> Controls which algorithm you are currently selecting.</p>\n<p><strong>X &amp; Y</strong> Controls various parameters of the algorithm for sound shaping. X usually maps more closely to pitch but it varies.</p>\n<p><strong>Z</strong>: Up toggles on a bitcrushing effect for crunchier noise. Middle is default, no effects.</p>\n<p>The momentary toggle down randomizes all your controls - it lets you quickly get a new noise sound when you tap it and your controls now will all be offset.</p>\n<p>Hold the momentary switch for over 2.5 seconds to reset this.</p>\n<p>INS:</p>\n<p><strong>CV In 1</strong>: Offset CV for the algorithm being selected.</p>\n<p><strong>CV In 2</strong>: VCA - you can gate your noise with this. Also great for AM modulation of the noise. With nothing plugged in, this normalizes to always being on.</p>\n<p><strong>CV In 3</strong>: Offset CV for X Knob</p>\n<p><strong>CV In 4</strong>: Offset CV for Y Knob</p>\n<p><strong>Pulse (CV In 5)</strong>: Sample and Hold trigger (to be detailed further below)</p>\n<p><strong>Pulse (CV In 6)</strong>: Gate to turn on and off the bitcrushing effect. Effect is on when input is high.</p>\n<p>OUTS:</p>\n<p><strong>CV Out 1/CV Out 2</strong>: Output of the noise algorithm and its current parameters. Both outs have the same source. I may consider making CV Out 2 go through a rainbow of noise instead.</p>\n<p><strong>CV Out 3:</strong> Output of the currently sample and held value, as determined by Pulse/CV In 5 - captures the current noise sample and holds until it receives another trigger.</p>\n<p><strong>CV Out 4</strong>: Slewed output of the above. Slew time is determined by the time between pulses in <strong>CV In 5</strong></p>\n<p><strong>Pulse/CV Out 5</strong>: A binary gate toggled on or off if the sample and held value is greater than 0. Good for random gate patterns. Again this requires a clock or some signal into Pulse/CV In 5</p>\n<p><strong>Pulse/CV Out 6</strong>: Realtime comparator signal from whether or not the noise sample is above 0. Really glitchy PWM sound.</p>",
    "has_documentation": false,
    "has_firmware": true
  },
  {
    "id": "14_cvmod",
    "number": "14",
    "title": "Cvmod",
    "description": "Quad CV delay inspired by Make Noise Multimod",
    "language": "C++ / ComputerCard / RPi Pico SDK",
    "creator": "Chris Johnson",
    "version": "1.0",
    "status": "Released",
    "pdf_files": [],
    "uf2_files": [
      "releases/14_cvmod/bin/cvmod.uf2"
    ],
    "readme": "# CVMod\n\nCVMod is a card inspired by Make Noise's *MultiMod* module. Its development is recorded in a [~3 hour video stream](https://www.youtube.com/watch?v=OXSL_SinqrY).\n\n\nCVMod simulates a loop of tape (up to 8 seconds long) onto which one channel of CV is recorded. Four tape 'read heads' move around the tape loop and their values are output onto jacks.\n\n### Controls/Jacks\n- **Audio In 1 jack**: CV input\n- **Audio/CV Out 1/2**: four CV outputs\n- **Knob X** (+ CV in 1): duration of tape loop\n- **Main Knob** (+ Audio in 2): speed of read heads. Speed matches record head when main knob is at 12-o'clock (top right LED lit)\n- **Knob Y** (+ CV in 2): phase of read heads (offset from recording head)\n- **Switch down**: Reset position of read heads\n- **Switch up**: toggle through read head motion types: Ramp/Saw/Triangle/Sin/Stepped\n",
    "readme_html": "<h1 id=\"cvmod\">CVMod</h1>\n<p>CVMod is a card inspired by Make Noise&rsquo;s <em>MultiMod</em> module. Its development is recorded in a <a href=\"https://www.youtube.com/watch?v=OXSL_SinqrY\">~3 hour video stream</a>.</p>\n<p>CVMod simulates a loop of tape (up to 8 seconds long) onto which one channel of CV is recorded. Four tape &lsquo;read heads&rsquo; move around the tape loop and their values are output onto jacks.</p>\n<h3 id=\"controlsjacks\">Controls/Jacks</h3>\n<ul>\n<li><strong>Audio In 1 jack</strong>: CV input</li>\n<li><strong>Audio/CV Out 1/2</strong>: four CV outputs</li>\n<li><strong>Knob X</strong> (+ CV in 1): duration of tape loop</li>\n<li><strong>Main Knob</strong> (+ Audio in 2): speed of read heads. Speed matches record head when main knob is at 12-o&rsquo;clock (top right LED lit)</li>\n<li><strong>Knob Y</strong> (+ CV in 2): phase of read heads (offset from recording head)</li>\n<li><strong>Switch down</strong>: Reset position of read heads</li>\n<li><strong>Switch up</strong>: toggle through read head motion types: Ramp/Saw/Triangle/Sin/Stepped</li>\n</ul>",
    "has_documentation": false,
    "has_firmware": true
  },
  {
    "id": "20_reverb",
    "number": "20",
    "title": "Reverb",
    "description": "Reverb effect, plus pulse/CV generators and MIDI-to-CV, configurable using web interface.",
    "language": "C (RPi Pico SDK)",
    "creator": "Chris Johnson",
    "version": "1.2",
    "status": "Released",
    "pdf_files": [],
    "uf2_files": [
      "releases/20_reverb/build/reverb_v1_2.uf2"
    ],
    "readme": "# reverb\n\nA simple reverb (on audio inputs/outputs) **plus** configurable MIDI interface / clock / Turing machine / bernoulli gate ( on CV / pulses inputs/outputs), for Music Thing Workshop System Computer.\n\nSee card documentation on the [Music Thing Modular website](https://www.musicthing.co.uk/Computer_Program_Cards/#20-reverb).\n\nReverb algorithm is that in the [Dattorro paper](https://ccrma.stanford.edu/~dattorro/EffectDesignPart1.pdf) (J. Audio Eng. Soc., **45**(9), 1997, 660&ndash;684), modified to damp either high or low frequencies in the reverb tail.\n\n## Use:\n\nA `uf2` file is included in the `build` directory.\n\n#### Compiling from source\n\nThe source is in C, using the Raspberry Pi Pico SDK. To compile:\n\n1. Set up the environment variable defining the path to the Pico SDK, e.g.:\n    `export PICO_SDK_PATH=<path_to_pico_sdk>`\n\tor equivalent for your shell.\n    \n2. Change to `20_reverb/` directory\n\n3. Make and build in the usual way for the Pico SDK:\n\n\n    mkdir build\n    cd build\n    cmake ..\n    make\n    \n   \n----\n\nAuthor: [Chris Johnson](https://github.com/chrisgjohnson)\n\nReverb DSP derived from code by [Pauli Pölkki](https://github.com/el-visio/dattorro-verb ) \n",
    "readme_html": "<h1 id=\"reverb\">reverb</h1>\n<p>A simple reverb (on audio inputs/outputs) <strong>plus</strong> configurable MIDI interface / clock / Turing machine / bernoulli gate ( on CV / pulses inputs/outputs), for Music Thing Workshop System Computer.</p>\n<p>See card documentation on the <a href=\"https://www.musicthing.co.uk/Computer_Program_Cards/#20-reverb\">Music Thing Modular website</a>.</p>\n<p>Reverb algorithm is that in the <a href=\"https://ccrma.stanford.edu/~dattorro/EffectDesignPart1.pdf\">Dattorro paper</a> (J. Audio Eng. Soc., <strong>45</strong>(9), 1997, 660&ndash;684), modified to damp either high or low frequencies in the reverb tail.</p>\n<h2 id=\"use\">Use:</h2>\n<p>A <code>uf2</code> file is included in the <code>build</code> directory.</p>\n<h4 id=\"compiling-from-source\">Compiling from source</h4>\n<p>The source is in C, using the Raspberry Pi Pico SDK. To compile:</p>\n<ol>\n<li>\n<p>Set up the environment variable defining the path to the Pico SDK, e.g.:\n    <code>export PICO_SDK_PATH=&lt;path_to_pico_sdk&gt;</code>\n    or equivalent for your shell.</p>\n</li>\n<li>\n<p>Change to <code>20_reverb/</code> directory</p>\n</li>\n<li>\n<p>Make and build in the usual way for the Pico SDK:</p>\n<p>mkdir build\ncd build\ncmake ..\nmake</p>\n</li>\n</ol>\n<hr />\n<p>Author: <a href=\"https://github.com/chrisgjohnson\">Chris Johnson</a></p>\n<p>Reverb DSP derived from code by <a href=\"https://github.com/el-visio/dattorro-verb\">Pauli Pölkki</a> </p>",
    "has_documentation": false,
    "has_firmware": true
  },
  {
    "id": "22_sheep",
    "number": "22",
    "title": "Sheep",
    "description": "A time-stretching and pitch-shifting granular processor and digital degradation playground with 2 fidelity options.",
    "language": "Pico SDK",
    "creator": "Dune Desormeaux",
    "version": "1.1",
    "status": "Released",
    "pdf_files": [
      "releases/22_sheep/Docs/sheep_doc.pdf"
    ],
    "uf2_files": [
      "releases/22_sheep/UF2/sheep_hifi.uf2",
      "releases/22_sheep/UF2/sheep_lofi.uf2"
    ],
    "readme": "",
    "readme_html": "",
    "has_documentation": true,
    "has_firmware": true
  },
  {
    "id": "23_SlowMod",
    "number": "23",
    "title": "Slowmod",
    "description": "Chaotic quad-LFO with VCAs",
    "language": "C++ (RPi Pico SDK) compat. w/ cmake and Arduino IDE.",
    "creator": "divmod/@olt",
    "version": "0.1",
    "status": "Released",
    "pdf_files": [],
    "uf2_files": [
      "releases/23_SlowMod/dist/slowmod-0.1.0.uf2"
    ],
    "readme": "SlowMod\n=======\n\nPowerful modulation for the Computer module of the Modular Music Thing Workshop\nSystem.\n\nIt offers four LFOs controled by the main knob. From minute long phases, up to\nlow audio rate. Audio1 is the fastes, CV2 the slowest.\n\nUse inputs acts as VCAs for the corresponding outputs.\n\nKnob X controls the intensity of cross modulation between the LFOs. Knob Y\ncrossfades each output with the inverted neighbor output (e.g. Audio 1 output\nfades between Audio 1 and inverted Audio 2). CCW for no crossfade; center to\nmirror both 1 and 2 outputs; CW to swap and invert 1 and 2; 8-10 oclock for\nwobbly CV output.\n\nPulse 1 and switch up pauses all LFOs.\nPulse 2 and switch down randomizes the phase of all LFOs.\n\n\nInstallation\n------------\n\nSee dist/ for pre-compiled .uf2 images.\n\nBuilding\n--------\n\nYou should be able to build this with both Arduino IDE and CMake.\n\nmdkir build\ncd build\ncmake ..\nmake\n\nSee dist/ for pre-compiled .uf2 images.\n\n\nThanks\n------\n\nThanks to TomWhitwell for building the Workshop System and chrisgjohnson for ComputerCard and SlowLFO.\n",
    "readme_html": "<h1 id=\"slowmod\">SlowMod</h1>\n<p>Powerful modulation for the Computer module of the Modular Music Thing Workshop\nSystem.</p>\n<p>It offers four LFOs controled by the main knob. From minute long phases, up to\nlow audio rate. Audio1 is the fastes, CV2 the slowest.</p>\n<p>Use inputs acts as VCAs for the corresponding outputs.</p>\n<p>Knob X controls the intensity of cross modulation between the LFOs. Knob Y\ncrossfades each output with the inverted neighbor output (e.g. Audio 1 output\nfades between Audio 1 and inverted Audio 2). CCW for no crossfade; center to\nmirror both 1 and 2 outputs; CW to swap and invert 1 and 2; 8-10 oclock for\nwobbly CV output.</p>\n<p>Pulse 1 and switch up pauses all LFOs.\nPulse 2 and switch down randomizes the phase of all LFOs.</p>\n<h2 id=\"installation\">Installation</h2>\n<p>See dist/ for pre-compiled .uf2 images.</p>\n<h2 id=\"building\">Building</h2>\n<p>You should be able to build this with both Arduino IDE and CMake.</p>\n<p>mdkir build\ncd build\ncmake ..\nmake</p>\n<p>See dist/ for pre-compiled .uf2 images.</p>\n<h2 id=\"thanks\">Thanks</h2>\n<p>Thanks to TomWhitwell for building the Workshop System and chrisgjohnson for ComputerCard and SlowLFO.</p>",
    "has_documentation": false,
    "has_firmware": true
  },
  {
    "id": "24_crafted_volts",
    "number": "24",
    "title": "Crafted Volts",
    "description": "Manually set control voltages (CV) with the input knobs and switch. It also attenuverts (attenuates and inverts) incoming voltages.",
    "language": "Rust (Embassy framework)",
    "creator": "Brian Dorsey",
    "version": "(see source repo)",
    "status": "Released",
    "pdf_files": [],
    "uf2_files": [],
    "readme": "\n# Crafted Volts \n\nA utility card for the WS Computer to manually set control voltages (CV)\nwith the input knobs and switch. It also attenuverts (attenuates and inverts)\nincoming voltages.\n\nCrafted Volts is developed in a different GitHub repo, visit [Crafted Volts](https://github.com/briandorsey/mtmws_cards/tree/main/crafted_volts) for documentation and to download releases of the UF2 image. \n",
    "readme_html": "<h1 id=\"crafted-volts\">Crafted Volts</h1>\n<p>A utility card for the WS Computer to manually set control voltages (CV)\nwith the input knobs and switch. It also attenuverts (attenuates and inverts)\nincoming voltages.</p>\n<p>Crafted Volts is developed in a different GitHub repo, visit <a href=\"https://github.com/briandorsey/mtmws_cards/tree/main/crafted_volts\">Crafted Volts</a> for documentation and to download releases of the UF2 image. </p>",
    "has_documentation": false,
    "has_firmware": false
  },
  {
    "id": "25_utility_pair",
    "number": "25",
    "title": "Utility Pair",
    "description": "25 small utilities, which can be combined in pairs",
    "language": "C++ / ComputerCard / PicoSDK",
    "creator": "Chris Johnson",
    "version": "1.0",
    "status": "Released",
    "pdf_files": [],
    "uf2_files": [],
    "readme": "# Utility Pair\n\n25 utilities, which can be combined in pairs.\n\nThe UF2 files and documentation are on the [utility pair website](https://www.chris-j.co.uk/utility_pair), while source code is in a [separate GitHub repository](https://github.com/chrisgjohnson/Utility-Pair)\n",
    "readme_html": "<h1 id=\"utility-pair\">Utility Pair</h1>\n<p>25 utilities, which can be combined in pairs.</p>\n<p>The UF2 files and documentation are on the <a href=\"https://www.chris-j.co.uk/utility_pair\">utility pair website</a>, while source code is in a <a href=\"https://github.com/chrisgjohnson/Utility-Pair\">separate GitHub repository</a></p>",
    "has_documentation": false,
    "has_firmware": false
  },
  {
    "id": "28_eighties_bass",
    "number": "28",
    "title": "Eighties Bass",
    "description": "Bass-oriented complete monosynth voice consisting of five detuned saw wave oscillators with mixable white noise and adjustable resonant filter.",
    "language": "arduino-pico core and Mozzi 2 library",
    "creator": "@todbot / Tod Kurt",
    "version": "0.1",
    "status": "Functional but WIP",
    "pdf_files": [],
    "uf2_files": [
      "releases/28_eighties_bass/build/28_eighties_bass.uf2"
    ],
    "readme": "# 30 - eighties_bass\n\nBass-oriented complete monosynth voice consisting of five detuned saw wave\noscillators with mixable white noise and adjustable resonant filter. \nCV controllable pitch, frequency cutoff, detune, noise mix\n\nVideo demo1: https://youtu.be/nrKnOlx8B3g\n\n##  Controls and Audio\n\n  - Main knob -- adjust filter cutoff frequency\n  - X knob -- set pitch offset (CV1 controls voct pitch) \n  - Y knob -- set filter resonance\n  - switch -- tap down to change filter\n  \n  - CV 1 in -- V/oct pitch\n  - CV 2 in -- +/- additive to main knob filter cutoff frequency\n  \n  - audio L in -- CV controls detune amount\n  - audio R in -- CV controls noise mix\n  \n  - LEDs -- LEDs 2,4,6 represent which filter mode (LPF, BPF, HPF)\n\n## Pre-built UF2\n- See `build` directory for a UF2 to copy to RPI-RP2 and you're off!\n\n\n## Building \n\n- Uses arduino-pico Arduino core: https://github.com/earlephilhower/arduino-pico\n- Uses Mozzi 2 library:  https://github.com/sensorium/Mozzi\n",
    "readme_html": "<h1 id=\"30-eighties_bass\">30 - eighties_bass</h1>\n<p>Bass-oriented complete monosynth voice consisting of five detuned saw wave\noscillators with mixable white noise and adjustable resonant filter. \nCV controllable pitch, frequency cutoff, detune, noise mix</p>\n<p>Video demo1: https://youtu.be/nrKnOlx8B3g</p>\n<h2 id=\"controls-and-audio\">Controls and Audio</h2>\n<ul>\n<li>Main knob &ndash; adjust filter cutoff frequency</li>\n<li>X knob &ndash; set pitch offset (CV1 controls voct pitch) </li>\n<li>Y knob &ndash; set filter resonance</li>\n<li>\n<p>switch &ndash; tap down to change filter</p>\n</li>\n<li>\n<p>CV 1 in &ndash; V/oct pitch</p>\n</li>\n<li>\n<p>CV 2 in &ndash; +/- additive to main knob filter cutoff frequency</p>\n</li>\n<li>\n<p>audio L in &ndash; CV controls detune amount</p>\n</li>\n<li>\n<p>audio R in &ndash; CV controls noise mix</p>\n</li>\n<li>\n<p>LEDs &ndash; LEDs 2,4,6 represent which filter mode (LPF, BPF, HPF)</p>\n</li>\n</ul>\n<h2 id=\"pre-built-uf2\">Pre-built UF2</h2>\n<ul>\n<li>See <code>build</code> directory for a UF2 to copy to RPI-RP2 and you&rsquo;re off!</li>\n</ul>\n<h2 id=\"building\">Building</h2>\n<ul>\n<li>Uses arduino-pico Arduino core: https://github.com/earlephilhower/arduino-pico</li>\n<li>Uses Mozzi 2 library:  https://github.com/sensorium/Mozzi</li>\n</ul>",
    "has_documentation": false,
    "has_firmware": true
  },
  {
    "id": "30_cirpy_wavetable",
    "number": "30",
    "title": "Cirpy Wavetable",
    "description": "Wavetable oscillator that using wavetables from Plaits, Braids, and Microwave,",
    "language": "Circuit Python",
    "creator": "@todbot / Tod Kurt",
    "version": "0.1",
    "status": "Functional but WIP",
    "pdf_files": [],
    "uf2_files": [
      "releases/30_cirpy_wavetable/build/30_cirpy_wavetable.uf2"
    ],
    "readme": "# 30 - cirpy_wavetable \n\nWavetable oscillator that using wavetables from Plaits, Braids, and Microwave, \nor any other [wavetable WAVs from waveeditonline](http://waveeditonline.com/index-17.html)\n\nVideo demo1: https://youtu.be/Y7sOgAC92XU\n\nVideo demo2: https://youtu.be/Nxx_5Xhv1X8\n\n##  Controls and Audio\n\n  - Main knob   -- controls wavetable position \n  - X knob      -- controls amount of triangle wave LFO to add to wavetable position \n  - Y knob      -- controls frequency of wavemod LFO\n  - Z switch down -- selects next wavetable\n  - Z switch up   -- toggles quantized notes or not on CV 1 Input\n  \n  - CV 1 In     -- pitch (0-5V) should kinda track 1V/oct, with nothing plugged in note = 36 MIDI\n  - CV 2 In     -- adds to main knob to control wavetable position\n\n  - CV 1 Out    -- reflects current wavetable position\n  - CV 2 Out    -- reflects wavemod LFO\n  \n  - Pulse 1 & 2 Out -- PWM audio out\n\n## Pre-built UF2\n- See `build` directory for a UF2 to copy to RPI-RP2 and you're off!\n- Also availble at https://github.com/todbot/Hello_Computer/releases/\n\nThe prebuilt UF2 contains the following wavetables:\n\n- PLAITS02.WAV -- Wavetable from [Mutable Instruments Plaits](https://mutable-instruments.net/modules/plaits/)\n- PLAITS01.WAV -- Wavetable from [Mutable Instruments Plaits](https://mutable-instruments.net/modules/plaits/)\n- BRAIDS01.WAV -- Wavetable from [Mutable Instruments Braids](https://mutable-instruments.net/modules/braids/)\n- BRAIDS02.WAV -- Wavetable from [Mutable Instruments Braids](https://mutable-instruments.net/modules/braids/)\n- BRAIDS03.WAV -- Wavetable from [Mutable Instruments Braids](https://mutable-instruments.net/modules/braids/)\n- MICROW02.WAV -- \"A curated set of wavetables from the [Waldorf Microwave 2](https://www.vintagesynth.com/waldorf/microwave-ii)\"\n\n## Setup if not using the pre-built UF2 file \n\n1. Install MTM CircuitPython UF2 from https://github.com/todbot/circuitpython/releases\n\n2. Copy the [`mtm_computer.py` file](https://github.com/TomWhitwell/Hello_Computer/tree/main/Demonstrations%2BHelloWorlds/CircuitPython) to the CIRCUITPY drive.\n\n3. Copy the `code.py` and `wav` directory to CIRCUITPY drive.\n\n4. Install the extra CircuitPython libraries with `circup install -r requirements.txt`\n\n5. Can use any [other WAV wavetables from waveeditonline.com](http://waveeditonline.com/index-17.html)\n   including other Plaits, Braids, and PPG wavetables, just drop them in `wav`. \n   The order they come up in the oscillator is based on their names.\n",
    "readme_html": "<h1 id=\"30-cirpy_wavetable\">30 - cirpy_wavetable</h1>\n<p>Wavetable oscillator that using wavetables from Plaits, Braids, and Microwave, \nor any other <a href=\"http://waveeditonline.com/index-17.html\">wavetable WAVs from waveeditonline</a></p>\n<p>Video demo1: https://youtu.be/Y7sOgAC92XU</p>\n<p>Video demo2: https://youtu.be/Nxx_5Xhv1X8</p>\n<h2 id=\"controls-and-audio\">Controls and Audio</h2>\n<ul>\n<li>Main knob   &ndash; controls wavetable position </li>\n<li>X knob      &ndash; controls amount of triangle wave LFO to add to wavetable position </li>\n<li>Y knob      &ndash; controls frequency of wavemod LFO</li>\n<li>Z switch down &ndash; selects next wavetable</li>\n<li>\n<p>Z switch up   &ndash; toggles quantized notes or not on CV 1 Input</p>\n</li>\n<li>\n<p>CV 1 In     &ndash; pitch (0-5V) should kinda track 1V/oct, with nothing plugged in note = 36 MIDI</p>\n</li>\n<li>\n<p>CV 2 In     &ndash; adds to main knob to control wavetable position</p>\n</li>\n<li>\n<p>CV 1 Out    &ndash; reflects current wavetable position</p>\n</li>\n<li>\n<p>CV 2 Out    &ndash; reflects wavemod LFO</p>\n</li>\n<li>\n<p>Pulse 1 &amp; 2 Out &ndash; PWM audio out</p>\n</li>\n</ul>\n<h2 id=\"pre-built-uf2\">Pre-built UF2</h2>\n<ul>\n<li>See <code>build</code> directory for a UF2 to copy to RPI-RP2 and you&rsquo;re off!</li>\n<li>Also availble at https://github.com/todbot/Hello_Computer/releases/</li>\n</ul>\n<p>The prebuilt UF2 contains the following wavetables:</p>\n<ul>\n<li>PLAITS02.WAV &ndash; Wavetable from <a href=\"https://mutable-instruments.net/modules/plaits/\">Mutable Instruments Plaits</a></li>\n<li>PLAITS01.WAV &ndash; Wavetable from <a href=\"https://mutable-instruments.net/modules/plaits/\">Mutable Instruments Plaits</a></li>\n<li>BRAIDS01.WAV &ndash; Wavetable from <a href=\"https://mutable-instruments.net/modules/braids/\">Mutable Instruments Braids</a></li>\n<li>BRAIDS02.WAV &ndash; Wavetable from <a href=\"https://mutable-instruments.net/modules/braids/\">Mutable Instruments Braids</a></li>\n<li>BRAIDS03.WAV &ndash; Wavetable from <a href=\"https://mutable-instruments.net/modules/braids/\">Mutable Instruments Braids</a></li>\n<li>MICROW02.WAV &ndash; &ldquo;A curated set of wavetables from the <a href=\"https://www.vintagesynth.com/waldorf/microwave-ii\">Waldorf Microwave 2</a>&ldquo;</li>\n</ul>\n<h2 id=\"setup-if-not-using-the-pre-built-uf2-file\">Setup if not using the pre-built UF2 file</h2>\n<ol>\n<li>\n<p>Install MTM CircuitPython UF2 from https://github.com/todbot/circuitpython/releases</p>\n</li>\n<li>\n<p>Copy the <a href=\"https://github.com/TomWhitwell/Hello_Computer/tree/main/Demonstrations%2BHelloWorlds/CircuitPython\"><code>mtm_computer.py</code> file</a> to the CIRCUITPY drive.</p>\n</li>\n<li>\n<p>Copy the <code>code.py</code> and <code>wav</code> directory to CIRCUITPY drive.</p>\n</li>\n<li>\n<p>Install the extra CircuitPython libraries with <code>circup install -r requirements.txt</code></p>\n</li>\n<li>\n<p>Can use any <a href=\"http://waveeditonline.com/index-17.html\">other WAV wavetables from waveeditonline.com</a>\n   including other Plaits, Braids, and PPG wavetables, just drop them in <code>wav</code>. \n   The order they come up in the oscillator is based on their names.</p>\n</li>\n</ol>",
    "has_documentation": false,
    "has_firmware": true
  },
  {
    "id": "37_compulidean",
    "number": "37",
    "title": "Compulidean",
    "description": "Generative Euclidean drum + sample player.",
    "language": "C++/Arduino, with vscode+platformio.",
    "creator": "Tristan Rowley",
    "version": "(see source repo)",
    "status": "Functional, but WIP",
    "pdf_files": [],
    "uf2_files": [],
    "readme": "\n# Compulidean\n\nDrum machine/Euclidean generated drum patterns + drum machine.\n\nA WIP port of my [Microlidian](https://github.com/doctea/Microlidian) project to the Music Thing Modular Workshop System Computer.\n\nVisit [the github](https://github.com/doctea/compulidian) for code+documentation and [download UF2 image here](https://github.com/doctea/Compulidian/raw/refs/heads/main/firmware/firmware.uf2).\n\n",
    "readme_html": "<h1 id=\"compulidean\">Compulidean</h1>\n<p>Drum machine/Euclidean generated drum patterns + drum machine.</p>\n<p>A WIP port of my <a href=\"https://github.com/doctea/Microlidian\">Microlidian</a> project to the Music Thing Modular Workshop System Computer.</p>\n<p>Visit <a href=\"https://github.com/doctea/compulidian\">the github</a> for code+documentation and <a href=\"https://github.com/doctea/Compulidian/raw/refs/heads/main/firmware/firmware.uf2\">download UF2 image here</a>.</p>",
    "has_documentation": false,
    "has_firmware": false
  },
  {
    "id": "38_od",
    "number": "38",
    "title": "Od",
    "description": "Loopable chaotic Lorenz attractor trajectories and zero-crossings as CV and pulses, with sensitivity to initial conditions.",
    "language": "MicroPython",
    "creator": "M. John Mills",
    "version": "1.0",
    "status": "Released",
    "pdf_files": [],
    "uf2_files": [],
    "readme": "# Od\n\nOd is a program for the Music Thing Modular Workshop System's Computer\nmodule that simulates the Lorenz system in order to produce loop-able \ncontrol voltage and pulse signals that display sensitivity to initial conditions.\n\nTo use, download the latest .uf2 file from the \n[release page](https://github.com/MJLMills/mtmws_od/releases)\nand copy to the Computer module following the \n[Workshop System instructions](https://www.musicthing.co.uk/Computer_Program_Cards/).\nThe latest documentation is available \n[here](https://github.com/MJLMills/mtmws_od/blob/main/docs/od.pdf).\n\n### Issues and Contact\nThis project is developed and documented in\n[a separate repo](https://github.com/MJLMills/mtmws_od), issues and feature \nrequests can be raised there, or by finding the author via the Workshop System \nDiscord (@sneddo_trainer). The program uses the \n[pyworkshopsystem](https://github.com/MJLMills/pyworkshopsystem) repo, a\nreusable package for building programs for the Computer module with \nMicroPython.\n\n",
    "readme_html": "<h1 id=\"od\">Od</h1>\n<p>Od is a program for the Music Thing Modular Workshop System&rsquo;s Computer\nmodule that simulates the Lorenz system in order to produce loop-able \ncontrol voltage and pulse signals that display sensitivity to initial conditions.</p>\n<p>To use, download the latest .uf2 file from the \n<a href=\"https://github.com/MJLMills/mtmws_od/releases\">release page</a>\nand copy to the Computer module following the \n<a href=\"https://www.musicthing.co.uk/Computer_Program_Cards/\">Workshop System instructions</a>.\nThe latest documentation is available \n<a href=\"https://github.com/MJLMills/mtmws_od/blob/main/docs/od.pdf\">here</a>.</p>\n<h3 id=\"issues-and-contact\">Issues and Contact</h3>\n<p>This project is developed and documented in\n<a href=\"https://github.com/MJLMills/mtmws_od\">a separate repo</a>, issues and feature \nrequests can be raised there, or by finding the author via the Workshop System \nDiscord (@sneddo_trainer). The program uses the \n<a href=\"https://github.com/MJLMills/pyworkshopsystem\">pyworkshopsystem</a> repo, a\nreusable package for building programs for the Computer module with \nMicroPython.</p>",
    "has_documentation": false,
    "has_firmware": false
  },
  {
    "id": "42_backyard_rain",
    "number": "42",
    "title": "Backyard Rain",
    "description": "Nature soundscape audio. A cozy rain ambience mix for background listening. You control the intensity. This card plays rain ambience which was recorded in my backyard.",
    "language": "Rust (Embassy framework)",
    "creator": "Brian Dorsey",
    "version": "(see source repo)",
    "status": "Released",
    "pdf_files": [],
    "uf2_files": [],
    "readme": "\n# Backyard Rain Soundscape\n\nA port of the [Backyard Rain Soundscape](https://briandorsey.itch.io/backyard-rain-soundscape) Playdate app to the Music Thing Modular Workshop System Computer. \n\nNature soundscape audio. A cozy rain ambience mix for background listening. You control the intensity. This card plays rain ambience which was recorded in my backyard. \n\nBackyard Rain is developed in a different GitHub repo, visit [Backyard Rain](https://github.com/briandorsey/mtmws_cards/tree/main/backyard_rain) for documentation and to download releases of the UF2 image. \n",
    "readme_html": "<h1 id=\"backyard-rain-soundscape\">Backyard Rain Soundscape</h1>\n<p>A port of the <a href=\"https://briandorsey.itch.io/backyard-rain-soundscape\">Backyard Rain Soundscape</a> Playdate app to the Music Thing Modular Workshop System Computer. </p>\n<p>Nature soundscape audio. A cozy rain ambience mix for background listening. You control the intensity. This card plays rain ambience which was recorded in my backyard. </p>\n<p>Backyard Rain is developed in a different GitHub repo, visit <a href=\"https://github.com/briandorsey/mtmws_cards/tree/main/backyard_rain\">Backyard Rain</a> for documentation and to download releases of the UF2 image. </p>",
    "has_documentation": false,
    "has_firmware": false
  },
  {
    "id": "53_glitter",
    "number": "53",
    "title": "Glitter",
    "description": "Granular Looping Sampler",
    "language": "Pico SDK 2.1.1",
    "creator": "Steve Jones",
    "version": "0.1.0",
    "status": "Beta Test",
    "pdf_files": [],
    "uf2_files": [
      "releases/53_glitter/glitter_v0.1.2-beta.uf2"
    ],
    "readme": "# Glitter\n\nA two second sampler with stereo granulated playback for the Music Thing Modular Workshop System Computer.\n\n## Video manual\n\nhttps://youtu.be/JW8Z_I-ub2A\n\n## Latest Release\n\nhttps://github.com/sdrjones/mtws/releases/tag/glitter_v0.1.2-beta\n\n## Source repo\n\nhttps://github.com/sdrjones/mtws/tree/main/53_glitter\n\n## Note\n\nGlitter runs at a 192MHz clock speed. This is slightly less than the maximum supported clock speed in Pico\nSDK 2.1.1 but in previous SDKs it would have been considered to be overclocked. If you want to run at a lower\nclock speed without clicks then you would need to reduce the maximum number of grains and rebuild the code.\n\n## Summary\n\n* The loop is always playing. It will record the audio from the inputs when the switch is up or down.\n\n* Up to six grains are playing small random snippets of the loop. Their behaviour can be affected by the X/Y knobs and CV inputs, but they can't be completely controlled.\n\n## Cheat Sheet\n\n<img src=\"glitter_cheat_sheet.png\" width=\"250px\">\n\n## Controls\n\n**Z Switch**: Switch up or down to record to the loop.\n\nThe \"Up\" position is a useful hands-free continual record mode in which the grains will play back snippets\nfrom the previous two recorded seconds.\n\nThe \"Down\" position is good for punch in/out style recording. e.g. patch one oscillator's output to\nthe left audio input, and the other oscillator's output to the right input. Pick a couple of frequencies\nand flick the X switch down. A brief snippet of the output will be recorded to the loop, overwriting what\nwas there before. Rinse and repeat.\n\nNB. There is no dry or monitor output from glitter but you could patch that using stackables.\n\n---\n\n**Main Knob**: Fade between the plain loop (fully clockwise) and the granulated output (fully anti-clockwise).\n\n---\n\n**X Knob (In Play)**: Modify the chance of grains playing back at a different pitch. Chance of octave variations increases from fully anti-clockwise to half way. Chance of fifth variations increases from half way to fully clockwise.\n\nNB grains will only re-pitch if they can safely do so without tripping over the write head, so at longer lengths there won't be as much re-pitching.\n\n**X Knob (In Record)**: Adjust the mix between existing signal and new signal. Fully anti-clockwise is all\nnew signal, fully clockwise is all old signal.\n\n---\n\n**Y Knob**: Modify the maximum grain size. Clockwise is longer, anti-clockwise is shorter.\n\n---\n\n**CV1 in**: Modify the chance of the grains repeating themselves. Chance is maximum at 0V and decreases with\nmore positive voltage.\n\n---\n\n**CV2 in**: Modify the chance of the grains going to sleep.  Chance is maximum at 0V and decreases with\nmore positive voltage.\n\n---\n\n**Pulse 1 in**: With a steady clock input the grains' length and position shall be roughly quantised.\n\n---\n\n**LEDs**: Each LED shows the current level of a grain's output. Six LEDs, six grains - nice!\n\n## FAQ\n\n- The switch is up but I can't hear audio going to my loop - what's wrong?\n  - Check that the X Knob is not fully clockwise. In this position the mix of audio going to the loop is 100% existing vs 0% new. The idea of coding it this way is that when the knob is rolled back from this position slightly you can get nice long fade outs of the loop.\n\n## Credits\n\nThanks to Tom Whitwell for the amazing Music Thing Modular Workshop System.\n\nThanks to Chris Johnson for the excellent Utility-Pair examples.\n\nThanks to Dune Desormeaux, Brian Dorsey and the whole community of computer card creators whose work inspired me to have a go at this.\n",
    "readme_html": "<h1 id=\"glitter\">Glitter</h1>\n<p>A two second sampler with stereo granulated playback for the Music Thing Modular Workshop System Computer.</p>\n<h2 id=\"video-manual\">Video manual</h2>\n<p>https://youtu.be/JW8Z_I-ub2A</p>\n<h2 id=\"latest-release\">Latest Release</h2>\n<p>https://github.com/sdrjones/mtws/releases/tag/glitter_v0.1.2-beta</p>\n<h2 id=\"source-repo\">Source repo</h2>\n<p>https://github.com/sdrjones/mtws/tree/main/53_glitter</p>\n<h2 id=\"note\">Note</h2>\n<p>Glitter runs at a 192MHz clock speed. This is slightly less than the maximum supported clock speed in Pico\nSDK 2.1.1 but in previous SDKs it would have been considered to be overclocked. If you want to run at a lower\nclock speed without clicks then you would need to reduce the maximum number of grains and rebuild the code.</p>\n<h2 id=\"summary\">Summary</h2>\n<ul>\n<li>\n<p>The loop is always playing. It will record the audio from the inputs when the switch is up or down.</p>\n</li>\n<li>\n<p>Up to six grains are playing small random snippets of the loop. Their behaviour can be affected by the X/Y knobs and CV inputs, but they can&rsquo;t be completely controlled.</p>\n</li>\n</ul>\n<h2 id=\"cheat-sheet\">Cheat Sheet</h2>\n<p><img src=\"glitter_cheat_sheet.png\" width=\"250px\"></p>\n<h2 id=\"controls\">Controls</h2>\n<p><strong>Z Switch</strong>: Switch up or down to record to the loop.</p>\n<p>The &ldquo;Up&rdquo; position is a useful hands-free continual record mode in which the grains will play back snippets\nfrom the previous two recorded seconds.</p>\n<p>The &ldquo;Down&rdquo; position is good for punch in/out style recording. e.g. patch one oscillator&rsquo;s output to\nthe left audio input, and the other oscillator&rsquo;s output to the right input. Pick a couple of frequencies\nand flick the X switch down. A brief snippet of the output will be recorded to the loop, overwriting what\nwas there before. Rinse and repeat.</p>\n<p>NB. There is no dry or monitor output from glitter but you could patch that using stackables.</p>\n<hr />\n<p><strong>Main Knob</strong>: Fade between the plain loop (fully clockwise) and the granulated output (fully anti-clockwise).</p>\n<hr />\n<p><strong>X Knob (In Play)</strong>: Modify the chance of grains playing back at a different pitch. Chance of octave variations increases from fully anti-clockwise to half way. Chance of fifth variations increases from half way to fully clockwise.</p>\n<p>NB grains will only re-pitch if they can safely do so without tripping over the write head, so at longer lengths there won&rsquo;t be as much re-pitching.</p>\n<p><strong>X Knob (In Record)</strong>: Adjust the mix between existing signal and new signal. Fully anti-clockwise is all\nnew signal, fully clockwise is all old signal.</p>\n<hr />\n<p><strong>Y Knob</strong>: Modify the maximum grain size. Clockwise is longer, anti-clockwise is shorter.</p>\n<hr />\n<p><strong>CV1 in</strong>: Modify the chance of the grains repeating themselves. Chance is maximum at 0V and decreases with\nmore positive voltage.</p>\n<hr />\n<p><strong>CV2 in</strong>: Modify the chance of the grains going to sleep.  Chance is maximum at 0V and decreases with\nmore positive voltage.</p>\n<hr />\n<p><strong>Pulse 1 in</strong>: With a steady clock input the grains&rsquo; length and position shall be roughly quantised.</p>\n<hr />\n<p><strong>LEDs</strong>: Each LED shows the current level of a grain&rsquo;s output. Six LEDs, six grains - nice!</p>\n<h2 id=\"faq\">FAQ</h2>\n<ul>\n<li>The switch is up but I can&rsquo;t hear audio going to my loop - what&rsquo;s wrong?</li>\n<li>Check that the X Knob is not fully clockwise. In this position the mix of audio going to the loop is 100% existing vs 0% new. The idea of coding it this way is that when the knob is rolled back from this position slightly you can get nice long fade outs of the loop.</li>\n</ul>\n<h2 id=\"credits\">Credits</h2>\n<p>Thanks to Tom Whitwell for the amazing Music Thing Modular Workshop System.</p>\n<p>Thanks to Chris Johnson for the excellent Utility-Pair examples.</p>\n<p>Thanks to Dune Desormeaux, Brian Dorsey and the whole community of computer card creators whose work inspired me to have a go at this.</p>",
    "has_documentation": false,
    "has_firmware": true
  },
  {
    "id": "55_fifths",
    "number": "55",
    "title": "Fifths",
    "description": "A quantizer/sequencer that can create harmony and nimbly traverse the circle of fifths in attempts to make jazz",
    "language": "Pico SDK",
    "creator": "Dune Desormeaux",
    "version": "1.0",
    "status": "Ready",
    "pdf_files": [
      "releases/55_fifths/Docs/fifths_doc.pdf"
    ],
    "uf2_files": [
      "releases/55_fifths/UF2/fifths.uf2"
    ],
    "readme": "",
    "readme_html": "",
    "has_documentation": true,
    "has_firmware": true
  },
  {
    "id": "77_Placeholder",
    "number": "77",
    "title": "Placeholder",
    "description": "Reserved for secret project",
    "language": "None",
    "creator": "None",
    "version": "0.0",
    "status": "None",
    "pdf_files": [],
    "uf2_files": [],
    "readme": "",
    "readme_html": "",
    "has_documentation": false,
    "has_firmware": false
  },
  {
    "id": "78_Talker",
    "number": "78",
    "title": "Talker",
    "description": "Proof of concept speech synthesizer, based on TalkiePCM, inspired by 1970s LPC speech synths.",
    "language": "C (RPi Pico SDK)",
    "creator": "Chris Johnson",
    "version": "0.1",
    "status": "Proof of concept",
    "pdf_files": [],
    "uf2_files": [
      "releases/78_Talker/uf2 Installer/78_Talker.uf2"
    ],
    "readme": "# Talker\n\nThis is an early proof of concept, which simply babbles random numbers. There is no way yet to control the flow of numbers.\n\nThis proof of concept uses\n- a (somewhat modified and extended) version of the [TalkiePCM](https://github.com/pschatzmann/TalkiePCM) library, which is a software implementation of Texas Instruments [Linear Predictive Coding](https://en.wikipedia.org/wiki/Linear_predictive_coding) (LPC) speech chips from the 70s/80s.\n- The ComputerCard framework from this Workshop_Computer repository (Demonstrations+HelloWorlds/PicoSDK/ComputerCard/)\n\nLPC is a method of compressing audio recordings of speech, by modelling the audio signal as the result of an 'exciter' (a pitched or noise-like sound source) being passed through a bank of bandpass filters. This description allows the signal to be compressed efficiently, because the parameters describing the exciter and filters change relatively slowly (~40Hz) compared to the audio sample rate.\n\nWhile the original goal of LPC was to reproduce the original recording as accurately as possible (at much reduced data rate), this Talker card is designed for more creative/musical use. As such, the speed and pitch of the speech can be controlled, and jack connections allow the exciter and/or filter bank to be modified (or replaced entirely) with external processing.\n\n### Controls\n\n- Switch:\n  - Up = continuous\n  - Middle = off\n  - Down = single word\n- Pitch is controlled by the Main knob + CV in 1 (attenuverted by knob X)\n- Speed of babbling: Knob Y + CV in 2\n\n### Output \n\n- Audio out 1: Speech output\n- Audio out 2: the pitched and noise components of the LPC exciter\n\n### Input\n\n- Audio in 1, if plugged in, replaces the pitched part (only) of the LPC exciter\n- CV out 1: exciter amplitude output\n- CV out 2: exciter pitch output\n\n\n\n\n---\n### License\n\nThis proof-of-concept is licensed under the GPL-3.0, due to its use of the TalkiePCM library.\n\n\n---\nAuthor: [Chris Johnson](https://github.com/chrisgjohnson)\n\nTalkiePCM is based on [Talkie](https://github.com/going-digital/Talkie) by Peter Knight \n",
    "readme_html": "<h1 id=\"talker\">Talker</h1>\n<p>This is an early proof of concept, which simply babbles random numbers. There is no way yet to control the flow of numbers.</p>\n<p>This proof of concept uses\n- a (somewhat modified and extended) version of the <a href=\"https://github.com/pschatzmann/TalkiePCM\">TalkiePCM</a> library, which is a software implementation of Texas Instruments <a href=\"https://en.wikipedia.org/wiki/Linear_predictive_coding\">Linear Predictive Coding</a> (LPC) speech chips from the 70s/80s.\n- The ComputerCard framework from this Workshop_Computer repository (Demonstrations+HelloWorlds/PicoSDK/ComputerCard/)</p>\n<p>LPC is a method of compressing audio recordings of speech, by modelling the audio signal as the result of an &lsquo;exciter&rsquo; (a pitched or noise-like sound source) being passed through a bank of bandpass filters. This description allows the signal to be compressed efficiently, because the parameters describing the exciter and filters change relatively slowly (~40Hz) compared to the audio sample rate.</p>\n<p>While the original goal of LPC was to reproduce the original recording as accurately as possible (at much reduced data rate), this Talker card is designed for more creative/musical use. As such, the speed and pitch of the speech can be controlled, and jack connections allow the exciter and/or filter bank to be modified (or replaced entirely) with external processing.</p>\n<h3 id=\"controls\">Controls</h3>\n<ul>\n<li>Switch:</li>\n<li>Up = continuous</li>\n<li>Middle = off</li>\n<li>Down = single word</li>\n<li>Pitch is controlled by the Main knob + CV in 1 (attenuverted by knob X)</li>\n<li>Speed of babbling: Knob Y + CV in 2</li>\n</ul>\n<h3 id=\"output\">Output</h3>\n<ul>\n<li>Audio out 1: Speech output</li>\n<li>Audio out 2: the pitched and noise components of the LPC exciter</li>\n</ul>\n<h3 id=\"input\">Input</h3>\n<ul>\n<li>Audio in 1, if plugged in, replaces the pitched part (only) of the LPC exciter</li>\n<li>CV out 1: exciter amplitude output</li>\n<li>CV out 2: exciter pitch output</li>\n</ul>\n<hr />\n<h3 id=\"license\">License</h3>\n<p>This proof-of-concept is licensed under the GPL-3.0, due to its use of the TalkiePCM library.</p>\n<hr />\n<p>Author: <a href=\"https://github.com/chrisgjohnson\">Chris Johnson</a></p>\n<p>TalkiePCM is based on <a href=\"https://github.com/going-digital/Talkie\">Talkie</a> by Peter Knight </p>",
    "has_documentation": false,
    "has_firmware": true
  },
  {
    "id": "88_Blank",
    "number": "88",
    "title": "Blank",
    "description": "Reserved for blank 88 cards",
    "language": "None",
    "creator": "Tom Whitwell",
    "version": "0",
    "status": "None",
    "pdf_files": [],
    "uf2_files": [],
    "readme": "",
    "readme_html": "",
    "has_documentation": false,
    "has_firmware": false
  }
]